<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>md/language-manual.md</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">md/language-manual.md</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#language-quick-reference"
id="toc-language-quick-reference">Language quick reference</a>
<ul>
<li><a href="#basic-language-syntax"
id="toc-basic-language-syntax">Basic language syntax</a>
<ul>
<li><a href="#whitespace" id="toc-whitespace">Whitespace</a></li>
<li><a href="#comments" id="toc-comments">Comments</a></li>
<li><a href="#keywords" id="toc-keywords">Keywords</a></li>
<li><a href="#identifiers" id="toc-identifiers">Identifiers</a></li>
<li><a href="#integers" id="toc-integers">Integers</a></li>
<li><a href="#floats" id="toc-floats">Floats</a></li>
<li><a href="#characters" id="toc-characters">Characters</a></li>
<li><a href="#text" id="toc-text">Text</a></li>
<li><a href="#literals" id="toc-literals">Literals</a></li>
</ul></li>
<li><a href="#operators-and-types"
id="toc-operators-and-types">Operators and types</a>
<ul>
<li><a href="#unary-operators" id="toc-unary-operators">Unary
operators</a></li>
<li><a href="#relational-operators"
id="toc-relational-operators">Relational operators</a></li>
<li><a href="#numeric-binary-operators"
id="toc-numeric-binary-operators">Numeric binary operators</a></li>
<li><a href="#bitwise-and-wrapping-binary-operators"
id="toc-bitwise-and-wrapping-binary-operators">Bitwise and wrapping
binary operators</a></li>
<li><a href="#text-operators" id="toc-text-operators">Text
operators</a></li>
<li><a href="#assignment-operators"
id="toc-assignment-operators">Assignment operators</a></li>
<li><a href="#operator-and-keyword-precedence"
id="toc-operator-and-keyword-precedence">Operator and keyword
precedence</a></li>
<li><a href="#programs" id="toc-programs">Programs</a></li>
<li><a href="#imports" id="toc-imports">Imports</a></li>
<li><a href="#libraries" id="toc-libraries">Libraries</a></li>
<li><a href="#declaration-syntax"
id="toc-declaration-syntax">Declaration syntax</a></li>
<li><a href="#expression-syntax" id="toc-expression-syntax">Expression
syntax</a></li>
<li><a href="#patterns" id="toc-patterns">Patterns</a></li>
</ul></li>
<li><a href="#type-syntax" id="toc-type-syntax">Type syntax</a>
<ul>
<li><a href="#primitive-types" id="toc-primitive-types">Primitive
types</a></li>
<li><a href="#type-bool" id="toc-type-bool">Type
<code>Bool</code></a></li>
<li><a href="#type-char" id="toc-type-char">Type
<code>Char</code></a></li>
<li><a href="#type-text" id="toc-type-text">Type
<code>Text</code></a></li>
<li><a href="#type-float" id="toc-type-float">Type
<code>Float</code></a></li>
<li><a href="#types-int-and-nat" id="toc-types-int-and-nat">Types
<code>Int</code> and <code>Nat</code></a></li>
<li><a href="#bounded-integers-int8-int16-int32-and-int64"
id="toc-bounded-integers-int8-int16-int32-and-int64">Bounded integers
<code>Int8</code>, <code>Int16</code>, <code>Int32</code> and
<code>Int64</code></a></li>
<li><a href="#bounded-naturals-nat8-nat16-nat32-and-nat64"
id="toc-bounded-naturals-nat8-nat16-nat32-and-nat64">Bounded naturals
<code>Nat8</code>, <code>Nat16</code>, <code>Nat32</code> and
<code>Nat64</code></a></li>
<li><a href="#type-blob" id="toc-type-blob">Type
<code>Blob</code></a></li>
<li><a href="#type-principal" id="toc-type-principal">Type
<code>Principal</code></a></li>
<li><a href="#error-type" id="toc-error-type">Error type</a></li>
<li><a href="#type-region" id="toc-type-region">Type
<code>Region</code></a></li>
<li><a href="#constructed-types" id="toc-constructed-types">Constructed
types</a></li>
<li><a href="#object-types" id="toc-object-types">Object types</a></li>
<li><a href="#variant-types" id="toc-variant-types">Variant
types</a></li>
<li><a href="#array-types" id="toc-array-types">Array types</a></li>
<li><a href="#null-type" id="toc-null-type">Null type</a></li>
<li><a href="#option-types" id="toc-option-types">Option types</a></li>
<li><a href="#function-types" id="toc-function-types">Function
types</a></li>
<li><a href="#async-types" id="toc-async-types">Async types</a></li>
<li><a href="#async-types-1" id="toc-async-types-1">Async*
types</a></li>
<li><a href="#tuple-types" id="toc-tuple-types">Tuple types</a></li>
<li><a href="#any-type" id="toc-any-type">Any type</a></li>
<li><a href="#none-type" id="toc-none-type">None type</a></li>
<li><a href="#intersection-type" id="toc-intersection-type">Intersection
type</a></li>
<li><a href="#union-type" id="toc-union-type">Union type</a></li>
<li><a href="#parenthesized-type"
id="toc-parenthesized-type">Parenthesized type</a></li>
<li><a href="#type-fields" id="toc-type-fields">Type fields</a></li>
<li><a href="#variant-type-fields" id="toc-variant-type-fields">Variant
type fields</a></li>
<li><a href="#sugar" id="toc-sugar">Sugar</a></li>
<li><a href="#type-parameters" id="toc-type-parameters">Type
parameters</a></li>
<li><a href="#type-arguments" id="toc-type-arguments">Type
arguments</a></li>
<li><a href="#well-formed-types" id="toc-well-formed-types">Well-formed
types</a></li>
<li><a href="#subtyping" id="toc-subtyping">Subtyping</a></li>
<li><a href="#sharability" id="toc-sharability">Sharability</a></li>
<li><a href="#stability" id="toc-stability">Stability</a></li>
</ul></li>
<li><a href="#static-and-dynamic-semantics"
id="toc-static-and-dynamic-semantics">Static and dynamic semantics</a>
<ul>
<li><a href="#programs-1" id="toc-programs-1">Programs</a></li>
<li><a href="#libraries-1" id="toc-libraries-1">Libraries</a></li>
<li><a href="#imports-and-urls" id="toc-imports-and-urls">Imports and
Urls</a></li>
<li><a href="#declaration-fields"
id="toc-declaration-fields">Declaration fields</a></li>
<li><a href="#sequence-of-declarations"
id="toc-sequence-of-declarations">Sequence of declarations</a></li>
<li><a href="#patterns-1" id="toc-patterns-1">Patterns</a></li>
<li><a href="#wildcard-pattern" id="toc-wildcard-pattern">Wildcard
pattern</a></li>
<li><a href="#identifier-pattern" id="toc-identifier-pattern">Identifier
pattern</a></li>
<li><a href="#literal-pattern" id="toc-literal-pattern">Literal
pattern</a></li>
<li><a href="#tuple-pattern" id="toc-tuple-pattern">Tuple
pattern</a></li>
<li><a href="#object-pattern" id="toc-object-pattern">Object
pattern</a></li>
<li><a href="#variant-pattern" id="toc-variant-pattern">Variant
pattern</a></li>
<li><a href="#annotated-pattern" id="toc-annotated-pattern">Annotated
pattern</a></li>
<li><a href="#option-pattern" id="toc-option-pattern">Option
pattern</a></li>
<li><a href="#or-pattern" id="toc-or-pattern">Or pattern</a></li>
<li><a href="#expression-declaration"
id="toc-expression-declaration">Expression declaration</a></li>
<li><a href="#let-declaration" id="toc-let-declaration">Let
declaration</a></li>
<li><a href="#let-else-declaration"
id="toc-let-else-declaration">Let-else declaration</a></li>
<li><a href="#var-declaration" id="toc-var-declaration">Var
declaration</a></li>
<li><a href="#type-declaration" id="toc-type-declaration">Type
declaration</a></li>
<li><a href="#object-declaration" id="toc-object-declaration">Object
declaration</a></li>
<li><a href="#function-declaration"
id="toc-function-declaration">Function declaration</a></li>
<li><a href="#class-declaration" id="toc-class-declaration">Class
declaration</a></li>
<li><a href="#identifiers-1" id="toc-identifiers-1">Identifiers</a></li>
<li><a href="#literals-1" id="toc-literals-1">Literals</a></li>
<li><a href="#unary-operators-1" id="toc-unary-operators-1">Unary
operators</a></li>
<li><a href="#binary-operators" id="toc-binary-operators">Binary
operators</a></li>
<li><a href="#relational-operators-1"
id="toc-relational-operators-1">Relational operators</a></li>
<li><a href="#pipe-operators-and-placeholder-expressions"
id="toc-pipe-operators-and-placeholder-expressions">Pipe operators and
placeholder expressions</a></li>
<li><a href="#tuples" id="toc-tuples">Tuples</a></li>
<li><a href="#option-expressions" id="toc-option-expressions">Option
expressions</a></li>
<li><a href="#variant-injection" id="toc-variant-injection">Variant
injection</a></li>
<li><a href="#objects" id="toc-objects">Objects</a></li>
<li><a href="#object-combinationextension"
id="toc-object-combinationextension">Object
combination/extension</a></li>
<li><a href="#object-projection-member-access"
id="toc-object-projection-member-access">Object projection (member
access)</a></li>
<li><a href="#special-member-access"
id="toc-special-member-access">Special member access</a></li>
<li><a href="#assignment" id="toc-assignment">Assignment</a></li>
<li><a href="#unary-compound-assignment"
id="toc-unary-compound-assignment">Unary compound assignment</a></li>
<li><a href="#binary-compound-assignment"
id="toc-binary-compound-assignment">Binary compound assignment</a></li>
<li><a href="#arrays" id="toc-arrays">Arrays</a></li>
<li><a href="#array-indexing" id="toc-array-indexing">Array
indexing</a></li>
<li><a href="#function-calls" id="toc-function-calls">Function
calls</a></li>
<li><a href="#functions" id="toc-functions">Functions</a></li>
<li><a href="#blocks" id="toc-blocks">Blocks</a></li>
<li><a href="#do" id="toc-do">Do</a></li>
<li><a href="#option-block" id="toc-option-block">Option block</a></li>
<li><a href="#null-break" id="toc-null-break">Null break</a></li>
<li><a href="#not" id="toc-not">Not</a></li>
<li><a href="#and" id="toc-and">And</a></li>
<li><a href="#or" id="toc-or">Or</a></li>
<li><a href="#if" id="toc-if">If</a></li>
<li><a href="#switch" id="toc-switch">Switch</a></li>
<li><a href="#while" id="toc-while">While</a></li>
<li><a href="#loop" id="toc-loop">Loop</a></li>
<li><a href="#loop-while" id="toc-loop-while">Loop-while</a></li>
<li><a href="#for" id="toc-for">For</a></li>
<li><a href="#label" id="toc-label">Label</a></li>
<li><a href="#labeled-loops" id="toc-labeled-loops">Labeled
loops</a></li>
<li><a href="#break" id="toc-break">Break</a></li>
<li><a href="#continue" id="toc-continue">Continue</a></li>
<li><a href="#return" id="toc-return">Return</a></li>
<li><a href="#async" id="toc-async">Async</a></li>
<li><a href="#await" id="toc-await">Await</a></li>
<li><a href="#async-1" id="toc-async-1">Async*</a></li>
<li><a href="#await-1" id="toc-await-1">Await*</a></li>
<li><a href="#throw" id="toc-throw">Throw</a></li>
<li><a href="#try" id="toc-try">Try</a></li>
<li><a href="#assert" id="toc-assert">Assert</a></li>
<li><a href="#type-annotation" id="toc-type-annotation">Type
annotation</a></li>
<li><a href="#candid-serialization" id="toc-candid-serialization">Candid
Serialization</a></li>
<li><a href="#declaration" id="toc-declaration">Declaration</a></li>
<li><a href="#ignore" id="toc-ignore">Ignore</a></li>
<li><a href="#debug" id="toc-debug">Debug</a></li>
<li><a href="#actor-references" id="toc-actor-references">Actor
references</a></li>
<li><a href="#parentheses" id="toc-parentheses">Parentheses</a></li>
<li><a href="#subsumption" id="toc-subsumption">Subsumption</a></li>
</ul></li>
<li><a href="#references" id="toc-references">References</a></li>
</ul></li>
</ul>
</nav>
<h1 id="language-quick-reference">Language quick reference</h1>
<!--
* targetting release 0.5.4
* [X] Categorise primitives and operations as arithmetic (A), logical (L), bitwise (B) and relational (R) and use these categories to concisely present categorized operators (unop, binop, relop, a(ssigning)op) etc.
* [ ] Various inline TBCs and TBRs and TODOs
* [ ] Typing of patterns
* [X] Variants
* [X] Object patterns
* [X] Import expressions
* [X] Complete draft of Try/Throw expressions and primitive Error/ErrorCode type
* [ ] Prelude
* [ ] Modules and static restriction
* [X] Type components and paths
* [ ] Prelude (move scattered descriptions of assorted prims like charToText here)
* [X] Split category R into E (Equality) and O (Ordering) if we don't want Bool to support O. (Actually renamed R to O, and defined ==/!= on _shared_ types.
* [X] Include actual grammar (extracted from menhir) in appendix?
* [ ] Prose description of definedness checks
* [ ] Platform changes: remove async expressions (and perhaps types); restrict await to shared calls.
* [X] Queries
* [X] Remove Shared type
* [X] Explain dot keys, dot vals and iterators
* [X] Debug expressions
* [X] Document punning in type record patterns: https://github.com/dfinity/motoko/pull/964
* [X] Update ErrorCode section
* [Floats] Literals type and operations
* [ ] Re-section so headings appear in content outline
-->

<p>This section serves as a technical reference for the previous
chapters and has specific technical information for readers with
specific interests. For example, this section provides technical details
of interest to the following audiences:</p>
<ul>
<li><p>Authors providing the higher-level documentation about the Motoko
programming language.</p></li>
<li><p>Compiler experts interested in the details of Motoko and its
compiler.</p></li>
<li><p>Advanced programmers who want to learn more about the lower-level
details of Motoko.</p></li>
</ul>
<p>The language quick reference is intended to provide complete
reference information about Motoko, but this section does <em>not</em>
provide explanatory text or usage information. Therefore, this section
is typically not suitable for readers who are new to programming
languages or who are looking for a general introduction to using
Motoko.</p>
<p>Throughout, we use the term canister to refer to an Internet Computer
canister smart contract.</p>
<h2 id="basic-language-syntax">Basic language syntax</h2>
<p>This section describes the basic language conventions you need to
know for programming in Motoko.</p>
<h3 id="whitespace">Whitespace</h3>
<p>Space, newline, horizontal tab, carriage return, line feed and form
feed are considered as whitespace. Whitespace is ignored but used to
separate adjacent keywords, identifiers and operators.</p>
<p>In the definition of some lexemes, the quick reference uses the
symbol <code>␣</code> to denote a single whitespace character.</p>
<h3 id="comments">Comments</h3>
<p>Single line comments are all characters following <code>//</code>
until the end of the same line.</p>
<pre class="motoko"><code>// single line comment
x = 1</code></pre>
<p>Single or multi-line comments are any sequence of characters
delimited by <code>/*</code> and <code>*/</code>:</p>
<pre class="motoko"><code>/* multi-line comments
   look like this, as in C and friends */</code></pre>
<p>Comments delimited by <code>/*</code> and <code>*/</code> may be
nested, provided the nesting is well-bracketed.</p>
<pre class="motoko"><code>/// I&#39;m a documentation comment
/// for a function</code></pre>
<p>Documentation comments start with <code>///</code> followed by a
space until the end of line, and get attached to the definition
immediately following them.</p>
<p>Deprecation comments start with <code>/// @deprecated</code> followed
by a space until the end of line, and get attached to the definition
immediately following them. They are only recognized in front of
<code>public</code> declarations.</p>
<p>All comments are treated as whitespace.</p>
<h3 id="keywords">Keywords</h3>
<p>The following keywords are reserved and may not be used as
identifiers:</p>
<pre class="bnf"><code>
actor and assert async async* await await* break case catch class
composite continue debug debug_show do else flexible false for
from_candid func if ignore import in module not null object or label
let loop private public query return shared stable switch system throw
to_candid true try type var while with</code></pre>
<h3 id="identifiers">Identifiers</h3>
<p>Identifiers are alpha-numeric, start with a letter and may contain
underscores:</p>
<pre class="bnf"><code>&lt;id&gt;   ::= Letter (Letter | Digit | _)*
Letter ::= A..Z | a..z
Digit  ::= 0..9</code></pre>
<h3 id="integers">Integers</h3>
<p>Integers are written as decimal or hexadecimal,
<code>Ox</code>-prefixed natural numbers. Subsequent digits may be
prefixed a single, semantically irrelevant, underscore.</p>
<pre class="bnf"><code>digit ::= [&#39;0&#39;-&#39;9&#39;]
hexdigit ::= [&#39;0&#39;-&#39;9&#39;&#39;a&#39;-&#39;f&#39;&#39;A&#39;-&#39;F&#39;]
num ::= digit (&#39;_&#39;? digit)*
hexnum ::= hexdigit (&#39;_&#39;? hexdigit)*
nat ::= num | &quot;0x&quot; hexnum</code></pre>
<p>Negative integers may be constructed by applying a prefix negation
<code>-</code> operation.</p>
<h3 id="floats">Floats</h3>
<p>Floating point literals are written in decimal or
<code>Ox</code>-prefixed hexadecimal scientific notation.</p>
<pre class="bnf"><code>let frac = num
let hexfrac = hexnum
let float =
    num &#39;.&#39; frac?
  | num (&#39;.&#39; frac?)? (&#39;e&#39; | &#39;E&#39;) sign? num
  | &quot;0x&quot; hexnum &#39;.&#39; hexfrac?
  | &quot;0x&quot; hexnum (&#39;.&#39; hexfrac?)? (&#39;p&#39; | &#39;P&#39;) sign? num</code></pre>
<p>The 'e' (or 'E') prefixes a base 10, decimal exponent; 'p' (or 'P')
prefixes a base 2, binary exponent. In both cases, the exponent is in
decimal notation.</p>
<p>:::note</p>
<p>the use of decimal notation, even for the base 2 exponent, is in
keeping with the established hexadecimal floating point literal syntax
of the <code>C</code> language.</p>
<p>:::</p>
<h3 id="characters">Characters</h3>
<p>A character is a single quote (<code>'</code>) delimited:</p>
<ul>
<li><p>Unicode character in UTF-8,</p></li>
<li><p><code>\</code>-escaped newline, carriage return, tab, single or
double quotation mark</p></li>
<li><p><code>\</code>-prefixed ASCII character (TBR),</p></li>
<li><p>or <code>\u{</code> hexnum <code>}</code> enclosed valid, escaped
Unicode character in hexadecimal (TBR).</p></li>
</ul>
<pre class="bnf"><code>ascii ::= [&#39;\x00&#39;-&#39;\x7f&#39;]
ascii_no_nl ::= [&#39;\x00&#39;-&#39;\x09&#39;&#39;\x0b&#39;-&#39;\x7f&#39;]
utf8cont ::= [&#39;\x80&#39;-&#39;\xbf&#39;]
utf8enc ::=
    [&#39;\xc2&#39;-&#39;\xdf&#39;] utf8cont
  | [&#39;\xe0&#39;] [&#39;\xa0&#39;-&#39;\xbf&#39;] utf8cont
  | [&#39;\xed&#39;] [&#39;\x80&#39;-&#39;\x9f&#39;] utf8cont
  | [&#39;\xe1&#39;-&#39;\xec&#39;&#39;\xee&#39;-&#39;\xef&#39;] utf8cont utf8cont
  | [&#39;\xf0&#39;] [&#39;\x90&#39;-&#39;\xbf&#39;] utf8cont utf8cont
  | [&#39;\xf4&#39;] [&#39;\x80&#39;-&#39;\x8f&#39;] utf8cont utf8cont
  | [&#39;\xf1&#39;-&#39;\xf3&#39;] utf8cont utf8cont utf8cont
utf8 ::= ascii | utf8enc
utf8_no_nl ::= ascii_no_nl | utf8enc

escape ::= [&#39;n&#39;&#39;r&#39;&#39;t&#39;&#39;\\&#39;&#39;\&#39;&#39;&#39;\&quot;&#39;]

character ::=
  | [^&#39;&quot;&#39;&#39;\\&#39;&#39;\x00&#39;-&#39;\x1f&#39;&#39;\x7f&#39;-&#39;\xff&#39;]
  | utf8enc
  | &#39;\\&#39;escape
  | &#39;\\&#39;hexdigit hexdigit
  | &quot;\\u{&quot; hexnum &#39;}&#39;
  | &#39;\n&#39;        // literal newline

char := &#39;\&#39;&#39; character &#39;\&#39;&#39;</code></pre>
<h3 id="text">Text</h3>
<p>A text literal is <code>"</code>-delimited sequence of
characters:</p>
<pre class="bnf"><code>text ::= &#39;&quot;&#39; character* &#39;&quot;&#39;</code></pre>
<p>Note that a text literal may span multiple lines.</p>
<h3 id="literals">Literals</h3>
<pre class="bnf"><code>&lt;lit&gt; ::=                                     literals
  &lt;nat&gt;                                         natural
  &lt;float&gt;                                       float
  &lt;char&gt;                                        character
  &lt;text&gt;                                        Unicode text</code></pre>
<p>Literals are constant values. The syntactic validity of a literal
depends on the precision of the type at which it is used.</p>
<h2 id="operators-and-types">Operators and types</h2>
<p>To simplify the presentation of available operators, operators and
primitive types are classified into basic categories:</p>
<table>
<thead>
<tr class="header">
<th>Abbreviation</th>
<th>Category</th>
<th>Supported opertions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>Arithmetic</td>
<td>arithmetic operations</td>
</tr>
<tr class="even">
<td>L</td>
<td>Logical</td>
<td>logical/Boolean operations</td>
</tr>
<tr class="odd">
<td>B</td>
<td>Bitwise</td>
<td>bitwise and wrapping operations</td>
</tr>
<tr class="even">
<td>O</td>
<td>Ordered</td>
<td>comparison</td>
</tr>
<tr class="odd">
<td>T</td>
<td>Text</td>
<td>concatenation</td>
</tr>
</tbody>
</table>
<p>Some types have several categories. For example, type
<code>Int</code> is both arithmetic (A) and ordered (O) and supports
both arithmetic addition (<code>+</code>) and relational less than
(<code>&lt;</code>) (amongst other operations).</p>
<h3 id="unary-operators">Unary operators</h3>
<table>
<thead>
<tr class="header">
<th><code>&lt;unop&gt;</code></th>
<th>Category</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-</code></td>
<td>A</td>
<td>numeric negation</td>
</tr>
<tr class="even">
<td><code>+</code></td>
<td>A</td>
<td>numeric identity</td>
</tr>
<tr class="odd">
<td><code>^</code></td>
<td>B</td>
<td>bitwise negation</td>
</tr>
</tbody>
</table>
<h3 id="relational-operators">Relational operators</h3>
<table>
<tbody>
<tr class="odd">
<td><code>&lt;relop&gt;</code></td>
<td>Category</td>
<td></td>
</tr>
<tr class="even">
<td><code>==</code></td>
<td></td>
<td>equals</td>
</tr>
<tr class="odd">
<td><code>!=</code></td>
<td></td>
<td>not equals</td>
</tr>
<tr class="even">
<td><code>␣&lt;␣</code></td>
<td>O</td>
<td>less than <em>(must be enclosed in whitespace)</em></td>
</tr>
<tr class="odd">
<td><code>␣&gt;␣</code></td>
<td>O</td>
<td>greater than <em>(must be enclosed in whitespace)</em></td>
</tr>
<tr class="even">
<td><code>&lt;=</code></td>
<td>O</td>
<td>less than or equal</td>
</tr>
<tr class="odd">
<td><code>&gt;=</code></td>
<td>O</td>
<td>greater than or equal</td>
</tr>
</tbody>
</table>
<p>Note that equality (<code>==</code>) and inequality (<code>!=</code>)
do not have categories. Instead, equality and inequality are applicable
to arguments of all <em>shared</em> types, including non-primitive,
compound types such as immutable arrays, records, and variants.</p>
<p>Equality and inequality are structural and based on the observable
content of their operands (as determined by their static type).</p>
<h3 id="numeric-binary-operators">Numeric binary operators</h3>
<table>
<thead>
<tr class="header">
<th><code>&lt;binop&gt;</code></th>
<th>Category</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>+</code></td>
<td>A</td>
<td>addition</td>
</tr>
<tr class="even">
<td><code>-</code></td>
<td>A</td>
<td>subtraction</td>
</tr>
<tr class="odd">
<td><code>*</code></td>
<td>A</td>
<td>multiplication</td>
</tr>
<tr class="even">
<td><code>/</code></td>
<td>A</td>
<td>division</td>
</tr>
<tr class="odd">
<td><code>%</code></td>
<td>A</td>
<td>modulo</td>
</tr>
<tr class="even">
<td><code>**</code></td>
<td>A</td>
<td>exponentiation</td>
</tr>
</tbody>
</table>
<h3 id="bitwise-and-wrapping-binary-operators">Bitwise and wrapping
binary operators</h3>
<table>
<thead>
<tr class="header">
<th><code>&lt;binop&gt;</code></th>
<th>Category</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&amp;</code></td>
<td>B</td>
<td>bitwise and</td>
</tr>
<tr class="even">
<td><code>|</code></td>
<td>B</td>
<td>bitwise or</td>
</tr>
<tr class="odd">
<td><code>^</code></td>
<td>B</td>
<td>exclusive or</td>
</tr>
<tr class="even">
<td><code>&lt;&lt;</code></td>
<td>B</td>
<td>shift left</td>
</tr>
<tr class="odd">
<td><code>␣&gt;&gt;</code></td>
<td>B</td>
<td>shift right <em>(must be preceded by whitespace)</em></td>
</tr>
<tr class="even">
<td><code>&lt;&lt;&gt;</code></td>
<td>B</td>
<td>rotate left</td>
</tr>
<tr class="odd">
<td><code>&lt;&gt;&gt;</code></td>
<td>B</td>
<td>rotate right</td>
</tr>
<tr class="even">
<td><code>+%</code></td>
<td>A</td>
<td>addition (wrap-on-overflow)</td>
</tr>
<tr class="odd">
<td><code>-%</code></td>
<td>A</td>
<td>subtraction (wrap-on-overflow)</td>
</tr>
<tr class="even">
<td><code>*%</code></td>
<td>A</td>
<td>multiplication (wrap-on-overflow)</td>
</tr>
<tr class="odd">
<td><code>**%</code></td>
<td>A</td>
<td>exponentiation (wrap-on-overflow)</td>
</tr>
</tbody>
</table>
<h3 id="text-operators">Text operators</h3>
<table>
<thead>
<tr class="header">
<th><code>&lt;binop&gt;</code></th>
<th>Category</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>#</code></td>
<td>T</td>
<td>concatenation</td>
</tr>
</tbody>
</table>
<h3 id="assignment-operators">Assignment operators</h3>
<table>
<thead>
<tr class="header">
<th><code>:=</code>, <code>&lt;unop&gt;=</code>,
<code>&lt;binop&gt;=</code></th>
<th>Category</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>:=</code></td>
<td>*</td>
<td>assignment (in place update)</td>
</tr>
<tr class="even">
<td><code>+=</code></td>
<td>A</td>
<td>in place add</td>
</tr>
<tr class="odd">
<td><code>-=</code></td>
<td>A</td>
<td>in place subtract</td>
</tr>
<tr class="even">
<td><code>*=</code></td>
<td>A</td>
<td>in place multiply</td>
</tr>
<tr class="odd">
<td><code>/=</code></td>
<td>A</td>
<td>in place divide</td>
</tr>
<tr class="even">
<td><code>%=</code></td>
<td>A</td>
<td>in place modulo</td>
</tr>
<tr class="odd">
<td><code>**=</code></td>
<td>A</td>
<td>in place exponentiation</td>
</tr>
<tr class="even">
<td><code>&amp;=</code></td>
<td>B</td>
<td>in place logical and</td>
</tr>
<tr class="odd">
<td><code>|=</code></td>
<td>B</td>
<td>in place logical or</td>
</tr>
<tr class="even">
<td><code>^=</code></td>
<td>B</td>
<td>in place exclusive or</td>
</tr>
<tr class="odd">
<td><code>&lt;&lt;=</code></td>
<td>B</td>
<td>in place shift left</td>
</tr>
<tr class="even">
<td><code>&gt;&gt;=</code></td>
<td>B</td>
<td>in place shift right</td>
</tr>
<tr class="odd">
<td><code>&lt;&lt;&gt;=</code></td>
<td>B</td>
<td>in place rotate left</td>
</tr>
<tr class="even">
<td><code>&lt;&gt;&gt;=</code></td>
<td>B</td>
<td>in place rotate right</td>
</tr>
<tr class="odd">
<td><code>+%=</code></td>
<td>B</td>
<td>in place add (wrap-on-overflow)</td>
</tr>
<tr class="even">
<td><code>-%=</code></td>
<td>B</td>
<td>in place subtract (wrap-on-overflow)</td>
</tr>
<tr class="odd">
<td><code>*%=</code></td>
<td>B</td>
<td>in place multiply (wrap-on-overflow)</td>
</tr>
<tr class="even">
<td><code>**%=</code></td>
<td>B</td>
<td>in place exponentiation (wrap-on-overflow)</td>
</tr>
<tr class="odd">
<td><code>#=</code></td>
<td>T</td>
<td>in place concatenation</td>
</tr>
</tbody>
</table>
<p>The category of a compound assignment
<code>&lt;unop&gt;=</code>/<code>&lt;binop&gt;=</code> is given by the
category of the operator
<code>&lt;unop&gt;</code>/<code>&lt;binop&gt;</code>.</p>
<h3 id="operator-and-keyword-precedence">Operator and keyword
precedence</h3>
<p>The following table defines the relative precedence and associativity
of operators and tokens, ordered from lowest to highest precedence.
Tokens on the same line have equal precedence with the indicated
associativity.</p>
<table>
<thead>
<tr class="header">
<th>Precedence</th>
<th>Associativity</th>
<th>Token</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LOWEST</td>
<td>none</td>
<td><code>if _ _</code> (no <code>else</code>), <code>loop _</code> (no
<code>while</code>)</td>
</tr>
<tr class="even">
<td>(higher)</td>
<td>none</td>
<td><code>else</code>, <code>while</code></td>
</tr>
<tr class="odd">
<td>(higher)</td>
<td>right</td>
<td><code>:=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>,
<code>/=</code>, <code>%=</code>, <code>**=</code>, <code>#=</code>,
<code>&amp;=</code>, <code>|=</code>, <code>^=</code>,
<code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>,
<code>&lt;&lt;&gt;=</code>, <code>&lt;&gt;&gt;=</code>,
<code>+%=</code>, <code>-%=</code>, <code>*%=</code>,
<code>**%=</code></td>
</tr>
<tr class="even">
<td>(higher)</td>
<td>left</td>
<td><code>:</code></td>
</tr>
<tr class="odd">
<td>(higher)</td>
<td>left</td>
<td>`</td>
</tr>
<tr class="even">
<td>(higher)</td>
<td>left</td>
<td><code>or</code></td>
</tr>
<tr class="odd">
<td>(higher)</td>
<td>left</td>
<td><code>and</code></td>
</tr>
<tr class="even">
<td>(higher)</td>
<td>none</td>
<td><code>==</code>, <code>!=</code>, <code>&lt;</code>,
<code>&gt;</code>, <code>&lt;=</code>, <code>&gt;</code>,
<code>&gt;=</code></td>
</tr>
<tr class="odd">
<td>(higher)</td>
<td>left</td>
<td><code>+</code>, <code>-</code>, <code>#</code>, <code>+%</code>,
<code>-%</code></td>
</tr>
<tr class="even">
<td>(higher)</td>
<td>left</td>
<td><code>*</code>, <code>/</code>, <code>%</code>, <code>*%</code></td>
</tr>
<tr class="odd">
<td>(higher)</td>
<td>left</td>
<td><code>|</code></td>
</tr>
<tr class="even">
<td>(higher)</td>
<td>left</td>
<td><code>&amp;</code></td>
</tr>
<tr class="odd">
<td>(higher)</td>
<td>left</td>
<td><code>^</code></td>
</tr>
<tr class="even">
<td>(higher)</td>
<td>none</td>
<td><code>&lt;&lt;</code>, <code>&gt;&gt;</code>,
<code>&lt;&lt;&gt;</code>, <code>&lt;&gt;&gt;</code></td>
</tr>
<tr class="odd">
<td>HIGHEST</td>
<td>left</td>
<td><code>**</code>, <code>**%</code></td>
</tr>
</tbody>
</table>
<h3 id="programs">Programs</h3>
<p>The syntax of a <em>program</em> <code>&lt;prog&gt;</code> is as
follows:</p>
<pre class="bnf"><code>&lt;prog&gt; ::=             programs
  &lt;imp&gt;;* &lt;dec&gt;;*</code></pre>
<p>A program is a sequence of imports <code>&lt;imp&gt;;*</code>
followed by a sequence of declarations <code>&lt;dec&gt;;*</code> that
ends with an optional actor or actor class declaration. The actor or
actor class declaration determines the main actor, if any, of the
program.</p>
<p>For now, compiled programs must obey the following additional
restrictions (not imposed on interpreted programs):</p>
<ul>
<li><p>a <code>shared</code> function can only appear as a public field
of an actor or actor class;</p></li>
<li><p>a program may contain at most one actor or actor class
declaration, i.e. the final main actor or actor class; and</p></li>
<li><p>any main actor class declaration should be <em>anonymous</em>; if
named, the class name should not be used as a value within the class and
will be reported as an unavailable identifier.</p></li>
</ul>
<p>The last two restrictions are designed to forbid programmatic actor
class recursion, pending compiler support.</p>
<p>Note that the parameters (if any) of an actor class must have shared
type (see <a href="#sharability">Sharability</a>). The parameters of a
program’s final actor class provide access to the corresponding canister
installation argument(s); the Candid type of this argument is determined
by the Candid projection of the Motoko type of the class parameter.</p>
<h3 id="imports">Imports</h3>
<p>The syntax of an <em>import</em> <code>&lt;imp&gt;</code> is as
follows:</p>
<pre class="bnf"><code>&lt;imp&gt; ::=                           imports
  import &lt;pat&gt; =? &lt;url&gt;

&lt;url&gt; ::=
  &quot;&lt;filepath&gt;&quot;                      import module from relative &lt;filepath&gt;.mo
  &quot;mo:&lt;package-name&gt;/&lt;filepath&gt;&quot;    import module from package
  &quot;canister:&lt;canisterid&gt;&quot;           import external actor by &lt;canisterid&gt;
  &quot;canister:&lt;name&gt;&quot;                 import external actor by &lt;name&gt;</code></pre>
<p>An import introduces a resource referring to a local source module,
module from a package of modules, or canister (imported as an actor).
The contents of the resource are bound to <code>&lt;pat&gt;</code>.</p>
<p>Though typically a simple identifier, <code>&lt;id&gt;</code>,
<code>&lt;pat&gt;</code> can also be any composite pattern binding
selective components of the resource.</p>
<p>The pattern must be irrefutable.</p>
<h3 id="libraries">Libraries</h3>
<p>The syntax of a <em>library</em> (that can be referenced in an
import) is as follows:</p>
<pre class="bnf"><code>&lt;lib&gt; ::=                                               library
  &lt;imp&gt;;* module &lt;id&gt;? (: &lt;typ&gt;)? =? &lt;obj-body&gt;           module
  &lt;imp&gt;;* &lt;shared-pat&gt;? actor class                       actor class
    &lt;id&gt; &lt;typ-params&gt;? &lt;pat&gt; (: &lt;typ&gt;)? &lt;class-body&gt;</code></pre>
<p>A library <code>&lt;lib&gt;</code> is a sequence of imports
<code>&lt;imp&gt;;*</code> followed by:</p>
<ul>
<li><p>a named or anonymous (module) declaration; or</p></li>
<li><p>a named actor class declaration.</p></li>
</ul>
<p>Libraries stored in <code>.mo</code> files may be referenced by
<code>import</code> declarations.</p>
<p>In a module library, the optional name <code>&lt;id&gt;?</code> is
only significant within the library and does not determine the name of
the library when imported. Instead, the imported name of a library is
determined by the <code>import</code> declaration, giving clients of the
library the freedom to choose library names (e.g. to avoid clashes).</p>
<p>An actor class library, because it defines both a type constructor
and a function with name <code>&lt;id&gt;</code>, is imported as a
module defining both a type and a function named
<code>&lt;id&gt;</code>. The name <code>&lt;id&gt;</code> is mandatory
and cannot be omitted. An actor class constructor is always
asynchronous, with return type <code>async T</code> where <code>T</code>
is the inferred type of the class body. Because actor construction is
asynchronous, an instance of an imported actor class can only be created
in an asynchronous context (i.e. in the body of a
(non-<code>query</code>) <code>shared</code> function, asynchronous
function, <code>async</code> expression or <code>async*</code>
expression).</p>
<h3 id="declaration-syntax">Declaration syntax</h3>
<p>The syntax of a <em>declaration</em> is as follows:</p>
<pre class="bnf"><code>&lt;dec&gt; ::=                                                               declaration
  &lt;exp&gt;                                                                  expression
  let &lt;pat&gt; = &lt;exp&gt;                                                      immutable, trap on match failure
  let &lt;pat&gt; = &lt;exp&gt; else &lt;block-or-exp&gt;                                  immutable, handle match failure
  var &lt;id&gt; (: &lt;typ&gt;)? = &lt;exp&gt;                                            mutable
  &lt;sort&gt; &lt;id&gt;? (: &lt;typ&gt;)? =? &lt;obj-body&gt;                                  object
  &lt;shared-pat&gt;? func &lt;id&gt;? &lt;typ-params&gt;? &lt;pat&gt; (: &lt;typ&gt;)? =? &lt;exp&gt;       function
  type &lt;id&gt; &lt;typ-params&gt;? = &lt;typ&gt;                                        type
  &lt;shared-pat&gt;? &lt;sort&gt;? class                                            class
    &lt;id&gt;? &lt;typ-params&gt;? &lt;pat&gt; (: &lt;typ&gt;)? &lt;class-body&gt;

&lt;obj-body&gt; ::=           object body
  { &lt;dec-field&gt;;* }       field declarations

&lt;class-body&gt; ::=         class body
  = &lt;id&gt;? &lt;obj-body&gt;      object body, optionally binding &lt;id&gt; to &#39;this&#39; instance
  &lt;obj-body&gt;              object body</code></pre>
<p>The syntax of a shared function qualifier with call-context pattern
is as follows:</p>
<pre class="bnf"><code>&lt;query&gt; ::=
 composite? query

&lt;shared-pat&gt; ::=
  shared &lt;query&gt;? &lt;pat&gt;?</code></pre>
<p>For <code>&lt;shared-pat&gt;</code>, an absent
<code>&lt;pat&gt;?</code> is shorthand for the wildcard pattern
<code>_</code>.</p>
<pre class="bnf"><code>&lt;dec-field&gt; ::=                                object declaration fields
  &lt;vis&gt;? &lt;stab&gt;? &lt;dec&gt;                           field

&lt;vis&gt; ::=                                      field visibility
  public
  private
  system

&lt;stab&gt; ::=                                     field stability (actor only)
  stable
  flexible</code></pre>
<p>The <em>visibility</em> qualifier <code>&lt;vis&gt;?</code>
determines the accessibility of every field <code>&lt;id&gt;</code>
declared by <code>&lt;dec&gt;</code>:</p>
<ul>
<li><p>An absent <code>&lt;vis&gt;?</code> qualifier defaults to
<code>private</code> visibility.</p></li>
<li><p>Visibility <code>private</code> restricts access to
<code>&lt;id&gt;</code> to the enclosing object, module or
actor.</p></li>
<li><p>Visibility <code>public</code> extends <code>private</code> with
external access to <code>&lt;id&gt;</code> using the dot notation
<code>&lt;exp&gt;.&lt;id&gt;</code>.</p></li>
<li><p>Visibility <code>system</code> extends <code>private</code> with
access by the run-time system.</p></li>
<li><p>Visibility <code>system</code> <em>may only</em> appear on
<code>func</code> declarations that are actor fields, and <em>must
not</em> appear anywhere else.</p></li>
</ul>
<p>The <em>stability</em> qualifier <code>&lt;stab&gt;</code> determines
the <em>upgrade</em> behaviour of actor fields:</p>
<ul>
<li><p>A stability qualifier <em>should</em> appear on <code>let</code>
and <code>var</code> declarations that are actor fields. An absent
stability qualifier defaults to <code>flexible</code>.</p></li>
<li><p><code>&lt;stab&gt;</code> qualifiers must not appear on fields of
objects or modules.</p></li>
<li><p>The pattern in a
<code>stable let &lt;pat&gt; = &lt;exp&gt;</code> declaration must be
<em>simple</em> where, a pattern <code>pat</code> is simple if it
(recursively) consists of</p>
<ul>
<li><p>a variable pattern <code>&lt;id&gt;</code>, or</p></li>
<li><p>an annotated simple pattern
<code>&lt;pat&gt; : &lt;typ&gt;</code>, or</p></li>
<li><p>a parenthesized simple pattern
<code>( &lt;pat&gt; )</code>.</p></li>
</ul></li>
</ul>
<h3 id="expression-syntax">Expression syntax</h3>
<p>The syntax of an <em>expression</em> is as follows:</p>
<pre class="bnf"><code>&lt;exp&gt; ::=                                      expressions
  &lt;id&gt;                                           variable
  &lt;lit&gt;                                          literal
  &lt;unop&gt; &lt;exp&gt;                                   unary operator
  &lt;exp&gt; &lt;binop&gt; &lt;exp&gt;                            binary operator
  &lt;exp&gt; &lt;relop&gt; &lt;exp&gt;                            binary relational operator
  _                                              placeholder expression
  &lt;exp&gt; |&gt; &lt;exp&gt;                                 pipe operator
  ( &lt;exp&gt;,* )                                    tuple
  &lt;exp&gt; . &lt;nat&gt;                                  tuple projection
  ? &lt;exp&gt;                                        option injection
  { &lt;exp-field&gt;;* }                              object
  { &lt;exp&gt; (and &lt;exp&gt;)* (with &lt;exp-field&gt;;+)? }   object combination/extension
  # id &lt;exp&gt;?                                    variant injection
  &lt;exp&gt; . &lt;id&gt;                                   object projection/member access
  &lt;exp&gt; := &lt;exp&gt;                                 assignment
  &lt;unop&gt;= &lt;exp&gt;                                  unary update
  &lt;exp&gt; &lt;binop&gt;= &lt;exp&gt;                           binary update
  [ var? &lt;exp&gt;,* ]                               array
  &lt;exp&gt; [ &lt;exp&gt; ]                                array indexing
  &lt;shared-pat&gt;? func &lt;func_exp&gt;                  function expression
  &lt;exp&gt; &lt;typ-args&gt;? &lt;exp&gt;                        function call
  not &lt;exp&gt;                                      negation
  &lt;exp&gt; and &lt;exp&gt;                                conjunction
  &lt;exp&gt; or &lt;exp&gt;                                 disjunction
  if &lt;exp&gt; &lt;block-or-exp&gt; (else &lt;block-or-exp&gt;)? conditional
  switch &lt;exp&gt; { (case &lt;pat&gt; &lt;block-or-exp&gt;;)+ } switch
  while &lt;exp&gt; &lt;block-or-exp&gt;                     while loop
  loop &lt;block-or-exp&gt; (while &lt;exp&gt;)?             loop
  for ( &lt;pat&gt; in &lt;exp&gt; ) &lt;block-or-exp&gt;          iteration
  label &lt;id&gt; (: &lt;typ&gt;)? &lt;block-or-exp&gt;           label
  break &lt;id&gt; &lt;exp&gt;?                              break
  continue &lt;id&gt;                                  continue
  return &lt;exp&gt;?                                  return
  async &lt;block-or-exp&gt;                           async expression
  await &lt;block-or-exp&gt;                           await future (only in async)
  async* &lt;block-or-exp&gt;                          delay an asynchronous computation
  await* &lt;block-or-exp&gt;                          await a delayed computation (only in async)
  throw &lt;exp&gt;                                    raise an error (only in async)
  try &lt;block-or-exp&gt; catch &lt;pat&gt; &lt;block-or-exp&gt;  catch an error (only in async)
  assert &lt;block-or-exp&gt;                          assertion
  &lt;exp&gt; : &lt;typ&gt;                                  type annotation
  &lt;dec&gt;                                          declaration
  ignore &lt;block-or-exp&gt;                          ignore value
  do &lt;block&gt;                                     block as expression
  do ? &lt;block&gt;                                   option block
  &lt;exp&gt; !                                        null break
  debug &lt;block-or-exp&gt;                           debug expression
  actor &lt;exp&gt;                                    actor reference
  to_candid ( &lt;exp&gt;,* )                          Candid serialization
  from_candid &lt;exp&gt;                              Candid deserialization
  (system &lt;exp&gt; . &lt;id&gt;)                          System actor class constructor
  ( &lt;exp&gt; )                                      parentheses

&lt;block-or-exp&gt; ::=
  &lt;block&gt;
  &lt;exp&gt;

&lt;block&gt; ::=
  { &lt;dec&gt;;* }</code></pre>
<h3 id="patterns">Patterns</h3>
<p>The syntax of a <em>pattern</em> is as follows:</p>
<pre class="bnf"><code>&lt;pat&gt; ::=                                      patterns
  _                                              wildcard
  &lt;id&gt;                                           variable
  &lt;unop&gt;? &lt;lit&gt;                                  literal
  ( &lt;pat&gt;,* )                                    tuple or brackets
  { &lt;pat-field&gt;;* }                              object pattern
  # &lt;id&gt; &lt;pat&gt;?                                  variant pattern
  ? &lt;pat&gt;                                        option
  &lt;pat&gt; : &lt;typ&gt;                                  type annotation
  &lt;pat&gt; or &lt;pat&gt;                                 disjunctive pattern

&lt;pat-field&gt; ::=                                object pattern fields
  &lt;id&gt; (: &lt;typ&gt;) = &lt;pat&gt;                         field
  &lt;id&gt; (: &lt;typ&gt;)                                 punned field</code></pre>
<h2 id="type-syntax">Type syntax</h2>
<p>Type expressions are used to specify the types of arguments,
constraints (a.k.a bounds) on type parameters, definitions of type
constructors, and the types of sub-expressions in type annotations.</p>
<pre class="bnf"><code>&lt;typ&gt; ::=                                     type expressions
  &lt;path&gt; &lt;typ-args&gt;?                            constructor
  &lt;sort&gt;? { &lt;typ-field&gt;;* }                     object
  { &lt;typ-tag&gt;;* }                               variant
  { # }                                         empty variant
  [ var? &lt;typ&gt; ]                                array
  Null                                          null type
  ? &lt;typ&gt;                                       option
  &lt;shared&gt;? &lt;typ-params&gt;? &lt;typ&gt; -&gt; &lt;typ&gt;        function
  async &lt;typ&gt;                                   future
  async* &lt;typ&gt;                                  delayed, asynchronous computation
  ( ((&lt;id&gt; :)? &lt;typ&gt;),* )                       tuple
  Any                                           top
  None                                          bottom
  &lt;typ&gt; and &lt;typ&gt;                               intersection
  &lt;typ&gt; or &lt;typ&gt;                                union
  Error                                         errors/exceptions
  ( &lt;typ&gt; )                                      parenthesized type

&lt;sort&gt; ::= (actor | module | object)

&lt;shared&gt; ::=                                 shared function type qualifier
  shared &lt;query&gt;?

&lt;path&gt; ::=                                   paths
  &lt;id&gt;                                         type identifier
  &lt;path&gt; . &lt;id&gt;                                projection</code></pre>
<p>An absent <code>&lt;sort&gt;?</code> abbreviates
<code>object</code>.</p>
<h3 id="primitive-types">Primitive types</h3>
<p>Motoko provides the following primitive type identifiers, including
support for Booleans, signed and unsigned integers and machine words of
various sizes, characters and text.</p>
<p>The category of a type determines the operators (unary, binary,
relational and in-place update via assignment) applicable to values of
that type.</p>
<table>
<thead>
<tr class="header">
<th>Identifier</th>
<th>Category</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="./base/Bool.md"><code>Bool</code></a></td>
<td>L</td>
<td>Boolean values <code>true</code> and <code>false</code> and logical
operators</td>
</tr>
<tr class="even">
<td><a href="./base/Char.md"><code>Char</code></a></td>
<td>O</td>
<td>Unicode characters</td>
</tr>
<tr class="odd">
<td><a href="./base/Text.md"><code>Text</code></a></td>
<td>T, O</td>
<td>Unicode strings of characters with concatenation <code>_ # _</code>
and iteration</td>
</tr>
<tr class="even">
<td><a href="./base/Float.md"><code>Float</code></a></td>
<td>A, O</td>
<td>64-bit floating point values</td>
</tr>
<tr class="odd">
<td><a href="./base/Int.md"><code>Int</code></a></td>
<td>A, O</td>
<td>signed integer values with arithmetic (unbounded)</td>
</tr>
<tr class="even">
<td><a href="./base/Int8.md"><code>Int8</code></a></td>
<td>A, O</td>
<td>signed 8-bit integer values with checked arithmetic</td>
</tr>
<tr class="odd">
<td><a href="./base/Int16.md"><code>Int16</code></a></td>
<td>A, O</td>
<td>signed 16-bit integer values with checked arithmetic</td>
</tr>
<tr class="even">
<td><a href="./base/Int32.md"><code>Int32</code></a></td>
<td>A, O</td>
<td>signed 32-bit integer values with checked arithmetic</td>
</tr>
<tr class="odd">
<td><a href="./base/Int64.md"><code>Int64</code></a></td>
<td>A, O</td>
<td>signed 64-bit integer values with checked arithmetic</td>
</tr>
<tr class="even">
<td><a href="./base/Nat.md"><code>Nat</code></a></td>
<td>A, O</td>
<td>non-negative integer values with arithmetic (unbounded)</td>
</tr>
<tr class="odd">
<td><a href="./base/Nat8.md"><code>Nat8</code></a></td>
<td>A, O</td>
<td>non-negative 8-bit integer values with checked arithmetic</td>
</tr>
<tr class="even">
<td><a href="./base/Nat16.md"><code>Nat16</code></a></td>
<td>A, O</td>
<td>non-negative 16-bit integer values with checked arithmetic</td>
</tr>
<tr class="odd">
<td><a href="./base/Nat32.md"><code>Nat32</code></a></td>
<td>A, O</td>
<td>non-negative 32-bit integer values with checked arithmetic</td>
</tr>
<tr class="even">
<td><a href="./base/Nat64.md"><code>Nat64</code></a></td>
<td>A, O</td>
<td>non-negative 64-bit integer values with checked arithmetic</td>
</tr>
<tr class="odd">
<td><a href="./base/Blob.md"><code>Blob</code></a></td>
<td>O</td>
<td>binary blobs with iterators</td>
</tr>
<tr class="even">
<td><a href="./base/Principal.md"><code>Principal</code></a></td>
<td>O</td>
<td>principals</td>
</tr>
<tr class="odd">
<td><a href="./base/Error.md"><code>Error</code></a></td>
<td></td>
<td>(opaque) error values</td>
</tr>
<tr class="even">
<td><a href="./base/Region.md"><code>Region</code></a></td>
<td></td>
<td>(opaque) stable memory region objects</td>
</tr>
</tbody>
</table>
<p>Although many of these types have linguistic support for literals and
operators, each primitive type also has an eponymous base library
providing related functions and values (see <a
href="./base-intro.md">Motoko Base Library</a>). For example, the <a
href="./base/Text.md"><code>Text</code></a> library provides common
functions on <code>Text</code> values.</p>
<h3 id="type-bool">Type <code>Bool</code></h3>
<p>The type <code>Bool</code> of category L (Logical) has values
<code>true</code> and <code>false</code> and is supported by one and two
branch <code>if _ &lt;exp&gt; (else &lt;exp&gt;)?</code>,
<code>not &lt;exp&gt;</code>, <code>_ and _</code> and
<code>_ or _</code> expressions. Expressions <code>if</code>,
<code>and</code> and <code>or</code> are short-circuiting.</p>
<!--
TODO: Comparison.
-->

<h3 id="type-char">Type <code>Char</code></h3>
<p>A <code>Char</code> of category O (Ordered) represents a character as
a code point in the Unicode character set.</p>
<p>Base library function <code>Char.toNat32(c)</code> converts a
<code>Char</code> value, <code>c</code> to its <code>Nat32</code> code
point. Function <code>Char.fromNat32(n)</code> converts a
<code>Nat32</code> value, <code>n</code>, in the range
<em>0x0..xD7FF</em> or <em>0xE000..0x10FFFF</em> of valid code points to
its <code>Char</code> value; this conversion traps on invalid arguments.
Function <code>Char.toText(c)</code> converts the <code>Char</code>
<code>c</code> into the corresponding, single character
<code>Text</code> value.</p>
<h3 id="type-text">Type <code>Text</code></h3>
<p>The type <code>Text</code> of categories T and O (Text, Ordered)
represents sequences of Unicode characters (i.e. strings). Function
<code>t.size</code> returns the number of characters in
<code>Text</code> value <code>t</code>. Operations on text values
include concatenation (<code>_ # _</code>) and sequential iteration over
characters via <code>t.chars</code> as in
<code>for (c : Char in t.chars()) { …​ c …​ }</code>.</p>
<!--
TODO: Comparison.
-->

<h3 id="type-float">Type <code>Float</code></h3>
<p>The type <code>Float</code> represents 64-bit floating point values
of categories A (Arithmetic) and O (Ordered).</p>
<p>The semantics of <code>Float</code> and its operations is in
accordance with standard <a
href="https://ieeexplore.ieee.org/document/8766229">IEEE 754-2019</a>
(See <a href="#references">References</a>).</p>
<p>Common functions and values are defined in base library
"base/Float".</p>
<h3 id="types-int-and-nat">Types <code>Int</code> and
<code>Nat</code></h3>
<p>The types <code>Int</code> and <code>Nat</code> are signed integral
and natural numbers of categories A (Arithmetic) and O (Ordered).</p>
<p>Both <code>Int</code> and <code>Nat</code> are arbitrary precision,
with only subtraction <code>-</code> on <code>Nat</code> trapping on
underflow.</p>
<p>The subtype relation <code>Nat &lt;: Int</code> holds, so every
expression of type <code>Nat</code> is also an expression of type
<code>Int</code> (but <em>not</em> vice versa). In particular, every
value of type <code>Nat</code> is also a value of type <code>Int</code>,
without change of representation.</p>
<h3 id="bounded-integers-int8-int16-int32-and-int64">Bounded integers
<code>Int8</code>, <code>Int16</code>, <code>Int32</code> and
<code>Int64</code></h3>
<p>The types <code>Int8</code>, <code>Int16</code>, <code>Int32</code>
and <code>Int64</code> represent signed integers with respectively 8,
16, 32 and 64 bit precision. All have categories A (Arithmetic), B
(Bitwise) and O (Ordered).</p>
<p>Operations that may under- or overflow the representation are checked
and trap on error.</p>
<p>The operations <code>+%</code>, <code>-%</code>, <code>*%</code> and
<code>**%</code> provide access to wrap-around, modular arithmetic.</p>
<p>As bitwise types, these types support bitwise operations <em>and</em>
(<code>&amp;</code>), <em>or</em> (<code>|</code>) and
<em>exclusive-or</em> (<code>^</code>). Further, they can be rotated
left (<code>&lt;&lt;&gt;</code>), right (<code>&lt;&gt;&gt;</code>), and
shifted left (<code>&lt;&lt;</code>), right (<code>&gt;&gt;</code>). The
right-shift preserves the two’s-complement sign. All shift and rotate
amounts are considered modulo the numbers’s bit width <em>n</em>.</p>
<p>Bounded integer types are not in subtype relationship with each other
or with other arithmetic types, and their literals need type annotation
if the type cannot be inferred from context, e.g.
<code>(-42 : Int16)</code>.</p>
<p>The corresponding module in the base library provides conversion
functions: Conversion to <code>Int</code>, checked and wrapping
conversions from <code>Int</code> and wrapping conversion to the bounded
natural type of the same size.</p>
<h3 id="bounded-naturals-nat8-nat16-nat32-and-nat64">Bounded naturals
<code>Nat8</code>, <code>Nat16</code>, <code>Nat32</code> and
<code>Nat64</code></h3>
<p>The types <code>Nat8</code>, <code>Nat16</code>, <code>Nat32</code>
and <code>Nat64</code> represent unsigned integers with respectively 8,
16, 32 and 64 bit precision. All have categories A (Arithmetic), B
(Bitwise) and O (Ordered).</p>
<p>Operations that may under- or overflow the representation are checked
and trap on error.</p>
<p>The operations <code>+%</code>, <code>-%</code>, <code>*%</code> and
<code>**%</code> provide access to the modular, wrap-on-overflow
operations.</p>
<p>As bitwise types, these types support bitwise operations <em>and</em>
(<code>&amp;</code>), <em>or</em> (<code>|</code>) and
<em>exclusive-or</em> (<code>^</code>). Further, they can be rotated
left (<code>&lt;&lt;&gt;</code>), right (<code>&lt;&gt;&gt;</code>), and
shifted left (<code>&lt;&lt;</code>), right (<code>&gt;&gt;</code>). The
right-shift is logical. All shift and rotate amounts are considered
modulo the number’s bit width <em>n</em>.</p>
<p>The corresponding module in the base library provides conversion
functions: Conversion to <code>Int</code>, checked and wrapping
conversions from <code>Int</code> and wrapping conversion to the bounded
natural type of the same size.</p>
<h3 id="type-blob">Type <code>Blob</code></h3>
<p>The type <code>Blob</code> of category O (Ordered) represents binary
blobs or sequences of bytes. Function <code>b.size</code> returns the
number of characters in <code>Blob</code> value <code>b</code>.
Operations on blob values include sequential iteration over bytes via
function <code>b.vals</code> as in
<code>for (v : Nat8 in b.vals()) { …​ v …​ }</code>.</p>
<h3 id="type-principal">Type <code>Principal</code></h3>
<p>The type <code>Principal</code> of category O (Ordered) represents
opaque principals such as canisters and users that can, for example, be
used to identify callers of shared functions and used for simple
authentication. Although opaque, principals may be converted to binary
<code>Blob</code> values for more efficient hashing and other
applications (see module <code>Principal</code> from the base
library).</p>
<h3 id="error-type">Error type</h3>
<p>Assuming base library import,</p>
<pre class="motoko"><code>import E &quot;mo:base/Error&quot;;</code></pre>
<p>Errors are opaque values constructed and examined with
operations:</p>
<ul>
<li><p><code>E.reject : Text -&gt; Error</code></p></li>
<li><p><code>E.code : Error -&gt; E.ErrorCode</code></p></li>
<li><p><code>E.message : Error -&gt; Text</code></p></li>
</ul>
<p>Type <code>E.ErrorCode</code> is equivalent to variant type:</p>
<pre class="motoko"><code>type ErrorCode = {
  // Fatal error.
  #system_fatal;
  // Transient error.
  #system_transient;
  // Destination invalid.
  #destination_invalid;
  // Explicit reject by canister code.
  #canister_reject;
  // Canister trapped.
  #canister_error;
  // Future error code (with unrecognized numeric code).
  #future : Nat32;
  // Error issuing inter-canister call
  // (indicating destination queue full or freezing threshold crossed).
  #call_error : { err_code : Nat32 }
};</code></pre>
<p>A constructed error <code>e = E.reject(t)</code> has
<code>E.code(e) = #canister_reject</code> and
<code>E.message(e) = t</code>.</p>
<p><code>Error</code> values can be thrown and caught within an
<code>async</code> expression or <code>shared</code> function (only).
See <a href="#throw">Throw</a> and <a href="#try">Try</a>.</p>
<p>Errors with codes other than <code>#canister_reject</code> (i.e.
<em>system</em> errors) may be caught and thrown, but not
user-constructed.</p>
<p>:::note</p>
<p>Exiting an async block or shared function with a
non-<code>#canister-reject</code> system error exits with a copy of the
error with revised code <code>#canister_reject</code> and the original
<code>Text</code> message. This prevents programmatic forgery of system
errors.</p>
<p>:::</p>
<p>:::note</p>
<p>On the Internet Computer, the act of issuing a call to a canister
function can fail, so that the call cannot (and will not be) performed.
This can happen due to a lack of canister resources, typically because
the local message queue for the destination canister is full, or because
performing the call would reduce the current cycle balance of the
calling canister to a level below its freezing threshold. Such call
failures are reported by throwing an <code>Error</code> with code
<code>#call_error { err_code = n }</code>, where <code>n</code> is the
non-zero <code>err_code</code> value returned by the Internet Computer.
Like other errors, call errors can be caught and handled using
<code>try ... catch ...</code> expressions, if desired.</p>
<p>:::</p>
<h3 id="type-region">Type <code>Region</code></h3>
<p>The type <code>Region</code> represents opague stable memory regions.
Region objects are dynamically allocated and independently growable.
They represent isolated partitions of IC stable memory. The region type
is stable (but not shared) and its objects, which are stateful, may be
stored in stable variables and data structures. Objects of type
<code>Region</code> are created and updated using the functions provided
by base library <code>Region</code>. See <a
href="stable-regions.md">Stable Regions</a> and library <a
href="./base/Region.md">Region</a> for more information.</p>
<h3 id="constructed-types">Constructed types</h3>
<p><code>&lt;path&gt; &lt;typ-args&gt;?</code> is the application of a
type identifier or path, either built-in (i.e. <code>Int</code>) or user
defined, to zero or more type <strong>arguments</strong>. The type
arguments must satisfy the bounds, if any, expected by the type
constructor’s type parameters (see <a
href="#well-formed-types">Well-formed types</a>).</p>
<p>Though typically a type identifier, more generally,
<code>&lt;path&gt;</code> may be a <code>.</code>-separated sequence of
actor, object or module identifiers ending in an identifier accessing a
type component of a value (for example,
<code>Acme.Collections.List</code>).</p>
<h3 id="object-types">Object types</h3>
<p><code>&lt;sort&gt;? { &lt;typ-field&gt;;* }</code> specifies an
object type by listing its zero or more named <em>type fields</em>.</p>
<p>Within an object type, the names of fields must be distinct (both by
name and hash value).</p>
<p>Object types that differ only in the ordering of the fields are
equivalent.</p>
<p>When <code>&lt;sort&gt;?</code> is <code>actor</code>, all fields
have <code>shared</code> function type (specifying messages).</p>
<h3 id="variant-types">Variant types</h3>
<p><code>{ &lt;typ-tag&gt;;* }</code> specifies a variant type by
listing its variant type fields as a sequence of
<code>&lt;typ-tag&gt;</code>s.</p>
<p>Within a variant type, the tags of its variants must be distinct
(both by name and hash value).</p>
<p>Variant types that differ only in the ordering of their variant type
fields are equivalent.</p>
<p><code>{ # }</code> specifies the empty variant type.</p>
<h3 id="array-types">Array types</h3>
<p><code>[ var? &lt;typ&gt; ]</code> specifies the type of arrays with
elements of type <code>&lt;typ&gt;</code>.</p>
<p>Arrays are immutable unless specified with qualifier
<code>var</code>.</p>
<h3 id="null-type">Null type</h3>
<p>The <code>Null</code> type has a single value, the literal
<code>null</code>. <code>Null</code> is a subtype of the option
<code>? T</code>, for any type <code>T</code>.</p>
<h3 id="option-types">Option types</h3>
<p><code>? &lt;typ&gt;</code> specifies the type of values that are
either <code>null</code> or a proper value of the form
<code>? &lt;v&gt;</code> where <code>&lt;v&gt;</code> has type
<code>&lt;typ&gt;</code>.</p>
<h3 id="function-types">Function types</h3>
<p>Type
<code>&lt;shared&gt;? &lt;typ-params&gt;? &lt;typ1&gt; -&gt; &lt;typ2&gt;</code>
specifies the type of functions that consume (optional) type parameters
<code>&lt;typ-params&gt;</code>, consume a value parameter of type
<code>&lt;typ1&gt;</code> and produce a result of type
<code>&lt;typ2&gt;</code>.</p>
<p>Both <code>&lt;typ1&gt;</code> and <code>&lt;typ2&gt;</code> may
reference type parameters declared in
<code>&lt;typ-params&gt;</code>.</p>
<p>If <code>&lt;typ1&gt;</code> or <code>&lt;typ2&gt;</code> (or both)
is a tuple type, then the length of that tuple type determines the
argument or result arity of the function type.</p>
<p>The optional <code>&lt;shared&gt;</code> qualifier specifies whether
the function value is shared, which further constrains the form of
<code>&lt;typ-params&gt;</code>, <code>&lt;typ1&gt;</code> and
<code>&lt;typ2&gt;</code> (see <a href="#sharability">Sharability</a>
below).</p>
<p>(Note that a <code>&lt;shared&gt;</code> function may itself be
<code>shared</code> or <code>shared query</code> or
<code>shared composite query</code>, determining the persistence of its
state changes.)</p>
<h3 id="async-types">Async types</h3>
<p><code>async &lt;typ&gt;</code> specifies a future producing a value
of type <code>&lt;typ&gt;</code>.</p>
<p>Future types typically appear as the result type of a
<code>shared</code> function that produces an <code>await</code>-able
value.</p>
<h3 id="async-types-1">Async* types</h3>
<p><code>async* &lt;typ&gt;</code> specifies a delayed, asynchronous
computation producing a value of type <code>&lt;typ&gt;</code>.</p>
<p>Computation types typically appear as the result type of a
<code>local</code> function that produces an <code>await*</code>-able
value.</p>
<p>(They cannot be used as the return types of <code>shared</code>
functions.)</p>
<h3 id="tuple-types">Tuple types</h3>
<p><code>( ((&lt;id&gt; :)? &lt;typ&gt;),* )</code> specifies the type
of a tuple with zero or more ordered components.</p>
<p>The optional identifier <code>&lt;id&gt;</code>, naming its
components, is for documentation purposes only and cannot be used for
component access. In particular, tuple types that differ only in the
names of components are equivalent.</p>
<p>The empty tuple type <code>()</code> is called the <em>unit
type</em>.</p>
<h3 id="any-type">Any type</h3>
<p>Type <code>Any</code> is the <em>top</em> type, i.e. the super-type
of all types. All values have type <code>Any</code>.</p>
<h3 id="none-type">None type</h3>
<p>Type <code>None</code> is the <em>bottom</em> type, a subtype of all
other types. No value has type <code>None</code>.</p>
<p>As an empty type, <code>None</code> can be used to specify the
impossible return value of an infinite loop or unconditional trap.</p>
<h3 id="intersection-type">Intersection type</h3>
<p>The type expression <code>&lt;typ1&gt; and &lt;typ2&gt;</code>
denotes the syntactic <em>intersection</em> between its two type
operands, that is, the greatest type that is a subtype of both. If both
types are incompatible, the intersection is <code>None</code>.</p>
<p>The intersection is <em>syntactic</em>, in that it does not consider
possible instantiations of type variables. The intersection of two type
variables is <code>None</code>, unless they are equal, or one is
declared to be a (direct or indirect) subtype of the other.</p>
<h3 id="union-type">Union type</h3>
<p>The type expression <code>&lt;typ1&gt; or &lt;typ2&gt;</code> denotes
the syntactic <em>union</em> between its two type operands, that is, the
smallest type that is a supertype of both. If both types are
incompatible, the union is <code>Any</code>.</p>
<p>The union is <em>syntactic</em>, in that it does not consider
possible instantiations of type variables. The union of two type
variables is the union of their bounds, unless the variables are equal,
or one is declared to be a (direct or indirect) subtype of the
other.</p>
<h3 id="parenthesized-type">Parenthesized type</h3>
<p>A function that takes an immediate, syntactic tuple of length <em>n
&gt;= 0</em> as its domain or range is a function that takes
(respectively returns) <em>n</em> values.</p>
<p>When enclosing the argument or result type of a function, which is
itself a tuple type, <code>( &lt;tuple-typ&gt; )</code> declares that
the function takes or returns a single (boxed) value of type
<code>&lt;tuple-type&gt;</code>.</p>
<p>In all other positions, <code>( &lt;typ&gt; )</code> has the same
meaning as <code>&lt;typ&gt;</code>.</p>
<h3 id="type-fields">Type fields</h3>
<pre class="bnf"><code>&lt;typ-field&gt; ::=                               object type fields
  &lt;id&gt; : &lt;typ&gt;                                  immutable value
  var &lt;id&gt; : &lt;typ&gt;                              mutable value
  &lt;id&gt; &lt;typ-params&gt;? &lt;typ1&gt; : &lt;typ2&gt;            function value (short-hand)
  type &lt;id&gt; &lt;typ-params&gt;? = &lt;typ&gt;               type component</code></pre>
<p>A type field specifies the name and type of a value field of an
object, or the name and definition of a type component of an object. The
value field names within a single object type must be distinct and have
non-colliding hashes. The type component names within a single object
type must also be distinct and have non-colliding hashes. Value fields
and type components reside in separate name spaces and thus may have
names in common.</p>
<p><code>&lt;id&gt; : &lt;typ&gt;</code> specifies an <em>immutable</em>
field, named <code>&lt;id&gt;</code> of type
<code>&lt;typ&gt;</code>.</p>
<p><code>var &lt;id&gt; : &lt;typ&gt;</code> specifies a
<em>mutable</em> field, named <code>&lt;id&gt;</code> of type
<code>&lt;typ&gt;</code>.</p>
<p><code>type &lt;id&gt; &lt;typ-params&gt;? = &lt;typ&gt;</code>
specifies a <em>type</em> component, with field name
<code>&lt;id&gt;</code>, abbreviating (parameterized) type
<code>&lt;typ&gt;</code>.</p>
<p>Unlike type declarations, a type component is not, in itself,
recursive (though it may abbreviate an existing recursive type). In
particular, the name <code>&lt;id&gt;</code> is not bound in
<code>&lt;typ&gt;</code> nor in any other fields of the enclosing object
type. The name <code>&lt;id&gt;</code> only determines the label to use
when accessing the definition through a record of this type (using the
dot notation).</p>
<h3 id="variant-type-fields">Variant type fields</h3>
<pre class="bnf"><code>&lt;typ-tag&gt; ::=                                 variant type fields
  # &lt;id&gt; : &lt;typ&gt;                                tag
  # &lt;id&gt;                                        unit tag (short-hand)</code></pre>
<p>A variant type field specifies the tag and type of a single variant
of an enclosing variant type. The tags within a single variant type must
be distinct and have non-colliding hashes.</p>
<p><code># &lt;id&gt; : &lt;typ&gt;</code> specifies an (immutable)
field, named <code>&lt;id&gt;</code> of type <code>&lt;typ&gt;</code>.
<code># &lt;id&gt;</code> is sugar for an (immutable) field, named
<code>&lt;id&gt;</code> of type <code>()</code>.</p>
<h3 id="sugar">Sugar</h3>
<p>When enclosed by an <code>actor</code> object type,
<code>&lt;id&gt; &lt;typ-params&gt;? &lt;typ1&gt; : &lt;typ2&gt;</code>
is syntactic sugar for an immutable field named <code>&lt;id&gt;</code>
of <code>shared</code> function type
<code>shared &lt;typ-params&gt;? &lt;typ1&gt; → &lt;typ2&gt;</code>.</p>
<p>When enclosed by a non-<code>actor</code> object type,
<code>&lt;id&gt; &lt;typ-params&gt;? &lt;typ1&gt; : &lt;typ2&gt;</code>
is syntactic sugar for an immutable field named <code>&lt;id&gt;</code>
of ordinary function type
<code>&lt;typ-params&gt;? &lt;typ1&gt; → &lt;typ2&gt;</code>.</p>
<h3 id="type-parameters">Type parameters</h3>
<pre class="bnf"><code>&lt;typ-params&gt; ::=                              type parameters
  &lt; typ-param,* &gt;
&lt;typ-param&gt;
  &lt;id&gt; &lt;: &lt;typ&gt;                               constrained type parameter
  &lt;id&gt;                                        unconstrained type parameter</code></pre>
<p>A type constructors, function value or function type may be
parameterised by a vector of comma-separated, optionally constrained,
type parameters.</p>
<p><code>&lt;id&gt; &lt;: &lt;typ&gt;</code> declares a type parameter
with constraint <code>&lt;typ&gt;</code>. Any instantiation of
<code>&lt;id&gt;</code> must subtype <code>&lt;typ&gt;</code> (at that
same instantiation).</p>
<p>Syntactic sugar <code>&lt;id&gt;</code> declares a type parameter
with implicit, trivial constraint <code>Any</code>.</p>
<p>The names of type parameters in a vector must be distinct.</p>
<p>All type parameters declared in a vector are in scope within its
bounds.</p>
<h3 id="type-arguments">Type arguments</h3>
<pre class="bnf"><code>&lt;typ-args&gt; ::=                                type arguments
  &lt; &lt;typ&gt;,* &gt;</code></pre>
<p>Type constructors and functions may take type arguments.</p>
<p>The number of type arguments must agree with the number of declared
type parameters of the type constructor.</p>
<p>For a function, the number of type arguments, when provided, must
agree with the number of declared type parameters of the function’s
type. Note that type arguments in function applications can typically be
omitted and inferred by the compiler.</p>
<p>Given a vector of type arguments instantiating a vector of type
parameters, each type argument must satisfy the instantiated bounds of
the corresponding type parameter.</p>
<h3 id="well-formed-types">Well-formed types</h3>
<p>A type <code>T</code> is well-formed only if (recursively) its
constituent types are well-formed, and:</p>
<ul>
<li><p>if <code>T</code> is <code>async U</code> or
<code>async* U</code> then <code>U</code> is shared, and</p></li>
<li><p>if <code>T</code> is
<code>shared &lt;query&gt;? U -&gt; V</code>:</p>
<ul>
<li><code>U</code> is shared and,</li>
<li><code>V == ()</code> and <code>&lt;query&gt;?</code> is absent,
or</li>
<li><code>V == async W</code> with <code>W</code> shared, and</li>
</ul></li>
<li><p>if <code>T</code> is <code>C&lt;T0, …​, Tn&gt;</code> where:</p>
<ul>
<li><p>a declaration
<code>type C&lt;X0 &lt;: U0, Xn &lt;: Un&gt;  = …​</code> is in scope,
and</p></li>
<li><p><code>Ti &lt;: Ui[ T0/X0, …​, Tn/Xn ]</code>, for each
<code>0 &lt;= i &lt;= n</code>.</p></li>
</ul></li>
<li><p>if <code>T</code> is <code>actor { …​ }</code> then all fields in
<code>…​</code> are immutable and have <code>shared</code> function
type.</p></li>
</ul>
<h3 id="subtyping">Subtyping</h3>
<p>Two types <code>T</code>, <code>U</code> are related by subtyping,
written <code>T &lt;: U</code>, whenever, one of the following
conditions is true:</p>
<ul>
<li><p><code>T</code> equals <code>U</code> (reflexivity).</p></li>
<li><p><code>U</code> equals <code>Any</code>.</p></li>
<li><p><code>T</code> equals <code>None</code>.</p></li>
<li><p><code>T</code> is a type parameter <code>X</code> declared with
constraint <code>U</code>.</p></li>
<li><p><code>T</code> is <code>Nat</code> and <code>U</code> is
<code>Int</code>.</p></li>
<li><p><code>T</code> is a tuple <code>(T0, …​, Tn)</code>,
<code>U</code> is a tuple <code>(U0, …​, Un)</code>, and for each
<code>0 &lt;= i &lt;= n</code>, <code>Ti &lt;: Ui</code>.</p></li>
<li><p><code>T</code> is an immutable array type <code>[ V ]</code>,
<code>U</code> is an immutable array type <code>[ W ]</code> and
<code>V &lt;: W</code>.</p></li>
<li><p><code>T</code> is a mutable array type <code>[ var V ]</code>,
<code>U</code> is a mutable array type <code>[ var W ]</code> and
<code>V == W</code>.</p></li>
<li><p><code>T</code> is <code>Null</code> and <code>U</code> is an
option type <code>? W</code> for some <code>W</code>.</p></li>
<li><p><code>T</code> is <code>? V</code>, <code>U</code> is
<code>? W</code> and <code>V &lt;: W</code>.</p></li>
<li><p><code>T</code> is a future <code>async V</code>, <code>U</code>
is a future <code>async W</code>, and <code>V &lt;: W</code>.</p></li>
<li><p><code>T</code> is an object type
<code>&lt;sort0&gt; { fts0 }</code>, <code>U</code> is an object type
<code>&lt;sort1&gt; { fts1 }</code> and</p>
<ul>
<li><p><code>&lt;sort0&gt;</code> == <code>&lt;sort1&gt;</code>, and,
for all fields,</p></li>
<li><p>if field <code>id : W</code> is in <code>fts1</code> then
<code>id : V</code> is in <code>fts0</code> and <code>V &lt;: W</code>,
and</p></li>
<li><p>if mutable field <code>var id : W</code> is in <code>fts1</code>
then <code>var id : V</code> is in <code>fts0</code> and
<code>V == W</code>.</p>
<p>(That is, object type <code>T</code> is a subtype of object type
<code>U</code> if they have same sort, every mutable field in
<code>U</code> super-types the same field in <code>T</code> and every
mutable field in <code>U</code> is mutable in <code>T</code> with an
equivalent type. In particular, <code>T</code> may specify more fields
than <code>U</code>. Note that this clause defines subtyping for all
sorts of object type, whether <code>module</code>, <code>object</code>
or <code>actor</code>.)</p></li>
</ul></li>
<li><p><code>T</code> is a variant type <code>{ fts0 }</code>,
<code>U</code> is a variant type <code>{ fts1 }</code> and</p>
<ul>
<li><p>if field <code># id : V</code> is in <code>fts0</code> then
<code># id : W</code> is in <code>fts1</code> and
<code>V &lt;: W</code>.</p>
<p>(That is, variant type <code>T</code> is a subtype of variant type
<code>U</code> if every field of <code>T</code> subtypes the same field
of <code>U</code>. In particular, <code>T</code> may specify fewer
variants than <code>U</code>.)</p></li>
</ul></li>
<li><p><code>T</code> is a function type
<code>&lt;shared&gt;? &lt;X0 &lt;: V0, ..., Xn &lt;: Vn&gt; T1 -&gt; T2</code>,
<code>U</code> is a function type
<code>&lt;shared&gt;? &lt;X0 &lt;: W0, ..., Xn &lt;: Wn&gt; U1 -&gt; U2</code>
and</p>
<ul>
<li><p><code>T</code> and <code>U</code> are either both equivalently
<code>&lt;shared&gt;?</code>, and</p></li>
<li><p>assuming constraints <code>X0 &lt;: W0, …​, Xn &lt;: Wn</code>
then</p>
<ul>
<li><p>for all <code>i</code>, <code>Wi == Vi</code>, and</p></li>
<li><p><code>U1 &lt;: T1</code>, and</p></li>
<li><p><code>T2 &lt;: U2</code>.</p>
<p>(That is, function type <code>T</code> is a subtype of function type
<code>U</code> if they have same <code>&lt;shared&gt;?</code>
qualification, they have the same type parameters (modulo renaming) and
assuming the bounds in <code>U</code>, every bound in <code>T</code>
supertypes the corresponding parameter bound in <code>U</code>
(contra-variance), the domain of <code>T</code> supertypes the domain of
<code>U</code> (contra-variance) and the range of <code>T</code>
subtypes the range of <code>U</code> (co-variance).)</p></li>
</ul></li>
</ul></li>
<li><p><code>T</code> (respectively <code>U</code>) is a constructed
type <code>C&lt;V0, …​, Vn&gt;</code> that is equal, by definition of
type constructor <code>C</code>, to <code>W</code>, and
<code>W &lt;: U</code> (respectively <code>U &lt;: W</code>).</p></li>
<li><p>For some type <code>V</code>, <code>T &lt;: V</code> and
<code>V &lt;: U</code> (<em>transitivity</em>).</p></li>
</ul>
<h3 id="sharability">Sharability</h3>
<p>A type <code>T</code> is <em>shared</em> if it is</p>
<ul>
<li><p><code>Any</code> or <code>None</code>, or</p></li>
<li><p>a primitive type other than <code>Error</code>, or</p></li>
<li><p>an option type <code>? V</code> where <code>V</code> is shared,
or</p></li>
<li><p>a tuple type <code>(T0, …​, Tn)</code> where all <code>Ti</code>
are shared, or</p></li>
<li><p>an immutable array type <code>[V]</code> where <code>V</code> is
shared, or</p></li>
<li><p>an <code>object</code> type where all fields are immutable and
have shared type, or</p></li>
<li><p>a variant type where all tags have shared type, or</p></li>
<li><p>a shared function type, or</p></li>
<li><p>an <code>actor</code> type.</p></li>
</ul>
<h3 id="stability">Stability</h3>
<p>Stability extends sharability to include mutable types. More
precisely:</p>
<p>A type <code>T</code> is <em>stable</em> if it is</p>
<ul>
<li><p><code>Any</code> or <code>None</code>, or</p></li>
<li><p>a primitive type other than <code>Error</code>, or</p></li>
<li><p>an option type <code>? V</code> where <code>V</code> is stable,
or</p></li>
<li><p>a tuple type <code>(T0, …​, Tn)</code> where all <code>Ti</code>
are stable, or</p></li>
<li><p>a (mutable or immutable) array type <code>[var? V]</code> where
<code>V</code> is stable, or</p></li>
<li><p>an <code>object</code> type where all fields have stable type,
or</p></li>
<li><p>a variant type where all tags have stable type, or</p></li>
<li><p>a shared function type, or</p></li>
<li><p>an <code>actor</code> type.</p></li>
</ul>
<p>This definition implies that every shared type is a stable type. The
converse does not hold: there are types that are stable but not shared
(notably types with mutable components).</p>
<p>The types of actor fields declared with the <code>stable</code>
qualifier must have stable type.</p>
<p>The (current) value of such a field is preserved upon
<em>upgrade</em>, whereas the values of other fields are reinitialized
after an upgrade.</p>
<p>Note: the primitive <code>Region</code> type is stable.</p>
<h2 id="static-and-dynamic-semantics">Static and dynamic semantics</h2>
<p>Below, we give a detailed account of the semantics of Motoko
programs.</p>
<p>For each <a href="#expression-syntax">expression form</a> and each <a
href="#declaration-syntax">declaration form</a>, we summarize its
semantics, both in static terms (based on typing) and dynamic terms
(based on program evaluation).</p>
<h3 id="programs-1">Programs</h3>
<p>A program <code>&lt;imp&gt;;* &lt;dec&gt;;*</code> has type
<code>T</code> provided:</p>
<ul>
<li><code>&lt;dec&gt;;*</code> has type <code>T</code> under the static
environment induced by the imports in <code>&lt;imp&gt;;*</code>.</li>
</ul>
<p>All type and value declarations within <code>&lt;dec&gt;;*</code> are
mutually-recursive.</p>
<p>A program evaluates by (transitively) evaluating the imports, binding
their values to the identifiers in <code>&lt;imp&gt;;*</code> and then
evaluating the sequence of declarations in
<code>&lt;dec&gt;;*</code>.</p>
<h3 id="libraries-1">Libraries</h3>
<p>Restrictions on the syntactic form of modules means that libraries
can have no side-effects.</p>
<p>The imports of a library are local and not re-exported in its
interface.</p>
<p>Multiple imports of the same library can be safely deduplicated
without loss of side-effects.</p>
<h4 id="module-libraries">Module libraries</h4>
<p>A library
<code>&lt;imp&gt;;* module &lt;id&gt;? (: &lt;typ&gt;)? =? &lt;obj-body&gt;</code>
is a sequence of imports <code>&lt;import&gt;;*</code> followed by a
single module declaration.</p>
<p>A library has module type <code>T</code> provided</p>
<ul>
<li><code>module &lt;id&gt;? (: &lt;typ&gt;)? =? &lt;obj-body&gt;</code>
has (module) type <code>T</code> under the static environment induced by
the imports in <code>&lt;import&gt;;*</code>.</li>
</ul>
<p>A module library evaluates by (transitively) evaluating its imports,
binding their values to the identifiers in <code>&lt;imp&gt;;*</code>
and then evaluating
<code>module &lt;id&gt;? =? &lt;obj-body&gt;</code>.</p>
<p>If <code>(: &lt;typ&gt;)?</code> is present, then <code>T</code> must
be a subtype of <code>&lt;typ&gt;</code>.</p>
<h4 id="actor-class-libraries">Actor class libraries</h4>
<p>The actor class library <code>&lt;imp&gt;;* &lt;dec&gt;</code> where
<code>&lt;dec&gt;</code> is of the form
<code>&lt;shared-pat&gt;? actor class &lt;id&gt; &lt;typ-params&gt;? &lt;pat&gt; (: &lt;typ&gt;)? &lt;class-body&gt;</code>
has type:</p>
<pre class="bnf"><code>module {
  type &lt;id&gt; = T;
  &lt;id&gt; : (U1,...,Un) -&gt; async T
}</code></pre>
<p>provided that:</p>
<ul>
<li>the actor class declaration <code>&lt;dec&gt;</code> has function
type <code>(U1, ...​, Un) -&gt; async T</code> under the static
environment induced by the imports in
<code>&lt;import&gt;;*</code>.</li>
</ul>
<p>Notice that the imported type of the function <code>&lt;id&gt;</code>
must be asynchronous.</p>
<p>An actor class library evaluates by (transitively) evaluating its
imports, binding their values to the identifiers in
<code>&lt;imp&gt;;*</code>, and evaluating the (derived) module:</p>
<pre class="bnf"><code>module {
  &lt;dec&gt;
}</code></pre>
<p>On the Internet Computer, if this library is imported as identifier
<code>Lib</code>, then calling
<code>await Lib.&lt;id&gt;(&lt;exp1&gt;, ..., &lt;expn&gt;)</code>,
installs a fresh instance of the actor class as an isolated IC canister,
passing the values of <code>&lt;exp1&gt;</code>, ...​,
<code>&lt;expn&gt;</code> as installation arguments, and returns a
reference to a (remote) actor of <em>type</em>
<code>Lib.&lt;id&gt;</code>, that is, <code>T</code>. Installation is
(necessarily) asynchronous.</p>
<h4 id="actor-class-management">Actor class management</h4>
<p>On the Internet Computer, the primary constructor of an imported
actor class always creates a new principal and installs a fresh instance
of the class as the code for that principal. While that is one way to
install a canister on the IC, it is not the only way.</p>
<p>To provide further control over the installation of actor classes,
Motoko endows each imported actor class with an extra, secondary
constructor, for use on the Internet Computer. This constructor takes an
additional first argument that tailors the installation. The constructor
is only available via special syntax that stresses its
<code>system</code> functionality.</p>
<p>Given some actor class constructor:</p>
<pre class="motoko"><code>Lib.&lt;id&gt; : (U1, ...​, Un) -&gt; async T</code></pre>
<p>Its secondary constructor is accessed as
<code>(system Lib.&lt;id&gt;)</code> with typing:</p>
<pre class="motoko"><code>(system Lib.&lt;id&gt;) :
  { #new : CanisterSettings;
    #install : Principal;
    #reinstall : actor {} ;
    #upgrade : actor {} }  -&gt;
    (U1, ...​, Un) -&gt; async T</code></pre>
<p>where</p>
<pre class="motoko"><code>  type CanisterSettings = {
     settings : ?{
        controllers : ?[Principal];
        compute_allocation : ?Nat;
        memory_allocation : ?Nat;
        freezing_threshold : ?Nat;
     }
  }</code></pre>
<p>Calling
<code>(system Lib.&lt;id&gt;)(&lt;exp&gt;)(&lt;exp1&gt;, ...​, &lt;expn&gt;)</code>
uses the first argument <code>&lt;exp&gt;</code>, a variant value, to
control the installation of the canister further. Arguments
<code>(&lt;exp1&gt;, ..., &lt;expn&gt;)</code> are just the
user-declared constructor arguments of types <code>U1, ..., Un</code>
that would also be passed to the primary constructor.</p>
<p>If <code>&lt;exp&gt;</code> is</p>
<ul>
<li><code>#new s</code>, where <code>s</code> has type
<code>CanisterSettings</code>: the call creates a fresh Internet
Computer principal <code>p</code>, with settings <code>s</code>, and
installs the instance to principal <code>p</code>.</li>
<li><code>#install p</code>, where <code>p</code> has type
<code>Principal</code>, the call installs the actor to an already
created Internet Computer principal <code>p</code>. The principal must
be empty (have no previously installed code) or the call will return an
error.</li>
<li><code>#upgrade a</code>, where <code>a</code> has type (or
supertype) <code>actor {}</code>, the call installs the instance as an
<em>upgrade</em> of actor <code>a</code>, using its current stable
storage to initialize stable variables and stable memory of the new
instance.</li>
<li><code>#reinstall a</code>, where <code>a</code> has type (or
supertype) <code>actor {}</code>, reinstalls the instance over the
existing actor <code>a</code>, discarding its stable variables and
stable memory.</li>
</ul>
<p>:::note</p>
<p>On the Internet Computer, calling the primary constructor
<code>Lib.&lt;id&gt;</code> is equivalent to calling the secondary
constructor <code>(system Lib.&lt;id&gt;)</code> with argument
<code>(#new {settings = null})</code> (i.e. using default settings).</p>
<p>:::</p>
<p>:::note</p>
<p>On the Internet Computer, calls to <code>Lib.&lt;id&gt;</code> and
<code>(system Lib.&lt;id&gt;)(#new ...)</code> must be provisioned with
enough cycles for the creation of a new principal. Other call variants
will use the cycles of the already allocated principal or actor.</p>
<p>:::</p>
<p>:::danger</p>
<p>The use of <code>#upgrade a</code> may be unsafe. Motoko will
currently not verify that the upgrade is compatible with the code
currently installed at <code>a</code>. (A future extension may verify
compatibilty with a dynamic check.)</p>
<p>The use of <code>#reinstall a</code> may be unsafe. Motoko cannot
verify that the reinstall is compatible with the code currently
installed in actor <code>a</code> (even with a dynamic check). A change
in interface may break any existing clients of <code>a</code>. The
current state of <code>a</code> will be lost.</p>
<p>:::</p>
<h3 id="imports-and-urls">Imports and Urls</h3>
<p>An import <code>import &lt;pat&gt; =? &lt;url&gt;</code> declares a
pattern <code>&lt;pat&gt;</code> bound to the contents of the text
literal <code>&lt;url&gt;</code>.</p>
<p><code>&lt;url&gt;</code> is a text literal that designates some
resource: a local library specified with a relative path, a named module
from a named package, or an external canister, referenced either by
numeric canister id or by a named alias, and imported as a Motoko
actor.</p>
<p>In detail, if <code>&lt;url&gt;</code> is of the form:</p>
<ul>
<li><p><code>"&lt;filepath&gt;"</code> then <code>&lt;pat&gt;</code> is
bound to the library module defined in file
<code>&lt;filepath&gt;.mo</code>. <code>&lt;filepath&gt;</code> is
interpreted relative to the absolute location of the enclosing file.
Note the <code>.mo</code> extension is implicit and should <em>not</em>
be included in <code>&lt;url&gt;</code>. For example,
<code>import U "lib/Util"</code> defines <code>U</code> to reference the
module in local file <code>./lib/Util</code>.</p></li>
<li><p><code>"mo:&lt;package-name&gt;/&lt;path&gt;"</code> then
<code>&lt;pat&gt;</code> is bound to the library module defined in file
<code>&lt;package-path&gt;/&lt;path&gt;.mo</code> in directory
<code>&lt;package-path&gt;</code> referenced by package alias
<code>&lt;package-name&gt;</code>. The mapping from
<code>&lt;package-name&gt;</code> to <code>&lt;package-path&gt;</code>
is determined by a compiler command-line argument
<code>--package &lt;package-name&gt; &lt;package-path&gt;</code>. For
example, <code>import L "mo:base/List"</code> defines <code>L</code> to
reference the <code>List</code> library in package alias
<code>base</code>.</p></li>
<li><p><code>"ic:&lt;canisterid&gt;"</code> then
<code>&lt;pat&gt;</code> is bound to a Motoko actor whose Motoko type is
determined by the canister’s IDL interface. The IDL interface of
canister <code>&lt;canisterid&gt;</code> must be found in file
<code>&lt;actorpath&gt;/&lt;canisterid&gt;.did</code>. The compiler
assumes that <code>&lt;actorpath&gt;</code> is specified by command line
argument <code>--actor-idl &lt;actorpath&gt;</code> and that file
<code>&lt;actorpath&gt;/&lt;canisterid&gt;.did</code> exists. For
example, <code>import C "ic:lg264-qjkae"</code> defines <code>C</code>
to reference the actor with canister id <code>lg264-qjkae</code> and IDL
file <code>lg264-qjkae.did</code>.</p></li>
<li><p><code>"canister:&lt;name&gt;"</code> is a symbolic reference to
canister alias <code>&lt;name&gt;</code>. The compiler assumes that the
mapping of <code>&lt;name&gt;</code> to <code>&lt;canisterid&gt;</code>
is specified by command line argument
<code>--actor-alias &lt;name&gt; ic:&lt;canisterid&gt;</code>. If so,
<code>"canister:&lt;name&gt;"</code> is equivalent to
<code>"ic:&lt;cansterid&gt;"</code> (see above). For example,
<code>import C "canister:counter"</code> defines <code>C</code> to
reference the actor otherwise known as <code>counter</code>.</p></li>
</ul>
<p>The case sensitivity of file references depends on the host operating
system so it is recommended not to distinguish resources by filename
casing alone.</p>
<p>(Remark: when building multi-canister projects with the <a
href="https://internetcomputer.org/docs/current/developer-docs/setup/install">IC
SDK</a>, Motoko programs can typically import canisters by alias (e.g.
<code>import C "canister:counter"</code>), without specifying low-level
canister ids (e.g. <code>import C "ic:lg264-qjkae"</code>). The SDK
tooling takes care of supplying the appropriate command-line arguments
to the Motoko compiler.)</p>
<p>(Remark: sensible choices for <code>&lt;pat&gt;</code> are
identifiers, such as <code>Array</code>, or object patterns like
<code>{ cons; nil = empty }</code>, which allow selective importing of
individual fields, under original or other names.)</p>
<h3 id="declaration-fields">Declaration fields</h3>
<p>A declaration field
<code>&lt;vis&gt;? &lt;stab&gt;? &lt;dec&gt;</code> defines zero or more
fields of an actor or object, according to the set of variables defined
by <code>&lt;dec&gt;</code>.</p>
<p>Any identifier bound by a <code>public</code> declaration appears in
the type of enclosing object, module or actor and is accessible via the
dot notation.</p>
<p>An identifier bound by a <code>private</code> or <code>system</code>
declaration is excluded from the type of the enclosing object, module or
actor and thus inaccessible.</p>
<p>The declaration field has type <code>T</code> provided:</p>
<ul>
<li><p><code>&lt;dec&gt;</code> has type <code>T</code>;</p></li>
<li><p>if <code>&lt;stab&gt;?</code> is <code>stable</code> then
<code>T</code> must be a stable type (see <a
href="#stability">Stability</a>).</p></li>
</ul>
<p>(Actor fields declared <code>flexible</code> (implicitly or
explicitly) can have any type, but will not be preserved across
upgrades.)</p>
<p>Sequences of declaration fields are evaluated in order by evaluating
their constituent declarations, with the following exception:</p>
<p>During an upgrade only, the value of a <code>stable</code>
declaration is obtained as follows:</p>
<ul>
<li><p>if the stable declaration was previously declared stable in the
retired actor, its initial value is inherited from the retired
actor.</p></li>
<li><p>if the stable declaration was not declared stable in the retired
actor, and is thus new, its value is obtained by evaluating
<code>&lt;dec&gt;</code>.</p></li>
</ul>
<p>For an upgrade to be safe:</p>
<ul>
<li>every stable identifier declared with type <code>T</code> in the
retired actor and declared stable and of type <code>U</code> in the
replacement actor, must satisfy <code>T &lt;: U</code>.</li>
</ul>
<p>This condition ensures that every stable variable is either fresh,
requiring initialization, or its value can be safely inherited from the
retired actor. Note that stable variables may be removed across
upgrades, or may simply be deprecated by an upgrade to type
<code>Any</code>.</p>
<h4 id="system-fields">System fields</h4>
<p>The declaration <code>&lt;dec&gt;</code> of a <code>system</code>
field must be a manifest <code>func</code> declaration with one of the
following names and types:</p>
<table>
<thead>
<tr class="header">
<th>name</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>heartbeat</code></td>
<td><code>() -&gt; async ()</code></td>
<td>heartbeat action</td>
</tr>
<tr class="even">
<td><code>timer</code></td>
<td><code>(Nat64 -&gt; ()) -&gt; async ()</code></td>
<td>timer action</td>
</tr>
<tr class="odd">
<td><code>inspect</code></td>
<td><code>{ caller : Principal; msg : &lt;Variant&gt;; arg : Blob } -&gt; Bool</code></td>
<td>message predicate</td>
</tr>
<tr class="even">
<td><code>preupgrade</code></td>
<td><code>() -&gt; ()</code></td>
<td>pre upgrade action</td>
</tr>
<tr class="odd">
<td><code>postupgrade</code></td>
<td><code>() -&gt; ()</code></td>
<td>post upgrade action</td>
</tr>
</tbody>
</table>
<ul>
<li><p><code>heartbeat</code>, when declared, is called on every
Internet Computer subnet <strong>heartbeat</strong>, scheduling an
asynchronous call to the <code>heartbeat</code> function. Due to its
<code>async</code> return type, a heartbeat function may send messages
and await results. The result of a heartbeat call, including any trap or
thrown error, is ignored. The implicit context switch means that the
time the heartbeat body is executed may be later than the time the
heartbeat was issued by the subnet.</p></li>
<li><p><code>timer</code>, when declared, is called as a response of the
canister global timer's expiration. The canister's global timer can be
manipulated with the passed-in function argument of type
<code>Nat64 -&gt; ()</code> (taking an absolute time in nanoseconds)
upon which libraries can build their own abstractions. When not declared
(and in absence of the <code>-no-timer</code> flag), this system action
is provided with default implementation by the compiler (additionally
<code>setTimer</code> and <code>cancelTimer</code> are available as
primitives).</p></li>
<li><p><code>inspect</code>, when declared, is called as a predicate on
every Internet Computer ingress message (with the exception of HTTP
query calls). The return value, a <code>Bool</code>, indicates whether
to accept or decline the given message. The argument type depends on the
interface of the enclosing actor (see <a
href="#inspect">Inspect</a>).</p></li>
<li><p><code>preupgrade</code>, when declared, is called during an
upgrade, immediately <em>before</em> the (current) values of the
(retired) actor’s stable variables are transferred to the replacement
actor.</p></li>
<li><p><code>postupgrade</code>, when declared, is called during an
upgrade, immediately <em>after</em> the (replacement) actor body has
initialized its fields (inheriting values of the retired actors' stable
variables), and before its first message is processed.</p></li>
</ul>
<p>These <code>preupgrade</code> and <code>postupgrade</code> system
methods provide the opportunity to save and restore in-flight data
structures (e.g. caches) that are better represented using non-stable
types.</p>
<p>During an upgrade, a trap occurring in the implicit call to
<code>preupgrade()</code> or <code>postupgrade()</code> causes the
entire upgrade to trap, preserving the pre-upgrade actor.</p>
<h5 id="inspect"><code>inspect</code></h5>
<p>Given a record of message attributes, this function produces a
<code>Bool</code> that indicates whether to accept or decline the
message by returning <code>true</code> or <code>false</code>. The
function is invoked (by the system) on each ingress message issue as an
Internet Computer <em>update call</em> (i.e. excluding non-replicated
query calls). Similar to a query, any side-effects of an invocation are
transient and discarded. A call that traps due to some fault has the
same result as returning <code>false</code> (message denial).</p>
<p>The argument type of <code>inspect</code> depends on the interface of
the enclosing actor. In particular, the formal argument of
<code>inspect</code> is a record of fields of the following types:</p>
<ul>
<li><p><code>caller : Principal</code>: the principal, possibly
anonymous, of the caller of the message;</p></li>
<li><p><code>arg : Blob</code>: the raw, binary content of the message
argument;</p></li>
<li><p><code>msg : &lt;variant&gt;</code>: a variant of
<em>decoding</em> functions, where
<code>&lt;variant&gt; == {…​; #&lt;id&gt;: () → T; …​}</code> contains one
variant per <code>shared</code> or <code>shared query</code> function,
<code>&lt;id&gt;</code>, of the actor. The variant’s tag identifies the
function to be called; The variant’s argument is a function that, when
applied, returns the (decoded) argument of the call as a value of type
<code>T</code>.</p></li>
</ul>
<p>Using a variant, tagged with <code>#&lt;id&gt;</code>, allows the
return type, <code>T</code>, of the decoding function to vary with the
argument type (also <code>T</code>) of the shared function
<code>&lt;id&gt;</code>.</p>
<p>The variant’s argument is a function so that one can avoid the
expense of message decoding (when appropriate).</p>
<p>:::danger</p>
<p>An actor that fails to declare system field <code>inspect</code> will
simply accept all ingress messages.</p>
<p>:::</p>
<p>:::note</p>
<p>Any <code>shared composite query</code> function in the interface is
<em>not</em> included in <code>&lt;variant&gt;</code> since, unlike a
<code>shared query</code>, it can only be invoked as a non-replicated
query call, never as an update call.</p>
<p>:::</p>
<h3 id="sequence-of-declarations">Sequence of declarations</h3>
<p>A sequence of declarations <code>&lt;dec&gt;;*</code> occurring in a
block, a program or embedded in the <code>&lt;dec-field&gt;;*</code>
sequence of an object body has type <code>T</code> provided:</p>
<ul>
<li><p><code>&lt;dec&gt;;*</code> is empty and <code>T == ()</code>;
or</p></li>
<li><p><code>&lt;dec&gt;;*</code> is non-empty and:</p></li>
<li><p>all value identifiers bound by <code>&lt;dec&gt;;*</code> are
distinct, and</p></li>
<li><p>all type identifiers bound by <code>&lt;dec&gt;;*</code> are
distinct, and</p></li>
<li><p>under the assumption that each value identifier
<code>&lt;id&gt;</code> in <code>&lt;dec&gt;;*</code> has type
<code>var_id? Tid</code>, and assuming the type definitions in
<code>&lt;dec&gt;;*</code>:</p></li>
<li><p>each declaration in <code>&lt;dec&gt;;*</code> is well-typed,
and</p></li>
<li><p>each value identifier <code>&lt;id&gt;</code> in bindings
produced by <code>&lt;dec&gt;;*</code> has type
<code>var_id? Tid</code>, and</p></li>
<li><p>all but the last <code>&lt;dec&gt;</code> in
<code>&lt;dec&gt;;*</code> of the form <code>&lt;exp&gt;</code> has type
<code>()</code>;</p></li>
<li><p>the last declaration in <code>&lt;dec&gt;;*</code> has type
<code>T</code>.</p></li>
</ul>
<p>Declarations in <code>&lt;dec&gt;;*</code> are evaluated
sequentially. The first declaration that traps causes the entire
sequence to trap. Otherwise, the result of the declaration is the value
of the last declaration in <code>&lt;dec&gt;;*</code>. In addition, the
set of value bindings defined by <code>&lt;dec&gt;;*</code> is the union
of the bindings introduced by each declaration in
<code>&lt;dec&gt;;*</code>.</p>
<p>It is a compile-time error if any declaration in
<code>&lt;dec&gt;;*</code> might require the value of an identifier
declared in <code>&lt;dec&gt;;*</code> before that identifier’s
declaration has been evaluated. Such <em>use-before-define</em> errors
are detected by a simple, conservative static analysis not described
here.</p>
<h3 id="patterns-1">Patterns</h3>
<p>Patterns bind function parameters, declare identifiers and decompose
values into their constituent parts in the cases of a
<code>switch</code> expression.</p>
<p>Matching a pattern against a value may <em>succeed</em>,
<em>binding</em> the corresponding identifiers in the pattern to their
matching values, or <em>fail</em>. Thus the result of a match is either
a successful binding, mapping identifiers of the pattern to values, or
failure.</p>
<p>The consequences of pattern match failure depends on the context of
the pattern.</p>
<ul>
<li><p>In a function application or <code>let</code>-binding, failure to
match the formal argument pattern or <code>let</code>-pattern causes a
<em>trap</em>.</p></li>
<li><p>In a <code>case</code> branch of a <code>switch</code>
expression, failure to match that case’s pattern continues with an
attempt to match the next case of the switch, trapping only when no such
case remains.</p></li>
</ul>
<h3 id="wildcard-pattern">Wildcard pattern</h3>
<p>The wildcard pattern <code>_</code> matches a single value without
binding its contents to an identifier.</p>
<h3 id="identifier-pattern">Identifier pattern</h3>
<p>The identifier pattern <code>&lt;id&gt;</code> matches a single value
and binds it to the identifier <code>&lt;id&gt;</code>.</p>
<h3 id="literal-pattern">Literal pattern</h3>
<p>The literal pattern <code>&lt;unop&gt;? &lt;lit&gt;</code> matches a
single value against the constant value of literal
<code>&lt;lit&gt;</code> and fails if they are not (structurally) equal
values.</p>
<p>For integer literals only, the optional <code>&lt;unop&gt;</code>
determines the sign of the value to match.</p>
<h3 id="tuple-pattern">Tuple pattern</h3>
<p>The tuple pattern <code>( &lt;pat&gt;,* )</code> matches a n-tuple
value against an n-tuple of patterns (both the tuple and pattern must
have the same number of items). The set of identifiers bound by each
component of the tuple pattern must be distinct.</p>
<p>The empty tuple pattern <code>()</code> is called the <em>unit
pattern</em>.</p>
<p>Pattern matching fails if one of the patterns fails to match the
corresponding item of the tuple value. Pattern matching succeeds if
every pattern matches the corresponding component of the tuple value.
The binding returned by a successful match is the disjoint union of the
bindings returned by the component matches.</p>
<h3 id="object-pattern">Object pattern</h3>
<p>The object pattern <code>{ &lt;pat-field&gt;;* }</code> matches an
object value, a collection of named field values, against a sequence of
named pattern fields. The set of identifiers bound by each field of the
object pattern must be distinct. The names of the pattern fields in the
object pattern must be distinct.</p>
<p>Object patterns support <em>punning</em> for concision. A punned
field <code>&lt;id&gt;</code> is shorthand for
<code>&lt;id&gt; = &lt;id&gt;</code>; Similarly, a typed, punned field
<code>&lt;id&gt; : &lt;typ&gt;</code> is short-hand for
<code>&lt;id&gt; = &lt;id&gt; : &lt;typ&gt;</code>. Both bind the
matched value of the field named <code>&lt;id&gt;</code> to the
identifier <code>&lt;id&gt;</code>.</p>
<p>Pattern matching fails if one of the pattern fields fails to match
the corresponding field value of the object value. Pattern matching
succeeds if every pattern field matches the corresponding named field of
the object value. The binding returned by a successful match is the
union of the bindings returned by the field matches.</p>
<p>The <code>&lt;sort&gt;</code> of the matched object type must be
determined by an enclosing type annotation or other contextual type
information.</p>
<h3 id="variant-pattern">Variant pattern</h3>
<p>The variant pattern <code># &lt;id&gt; &lt;pat&gt;?</code> matches a
variant value (of the form <code># &lt;id'&gt; v</code>) against a
variant pattern. An absent <code>&lt;pat&gt;?</code> is shorthand for
the unit pattern (<code>()</code>). Pattern matching fails if the tag
<code>&lt;id'&gt;</code> of the value is distinct from the tag
<code>&lt;id&gt;</code> of the pattern (i.e. <code>&lt;id&gt;</code>
&lt;&gt; <code>&lt;id'&gt;</code>); or the tags are equal but the value
<code>v</code> does not match the pattern <code>&lt;pat&gt;?</code>.
Pattern matching succeeds if the tag of the value is
<code>&lt;id&gt;</code> (i.e. <code>&lt;id'&gt;</code> =
<code>&lt;id&gt;</code>) and the value <code>v</code> matches the
pattern <code>&lt;pat&gt;?</code>. The binding returned by a successful
match is just the binding returned by the match of <code>v</code>
against <code>&lt;pat&gt;?</code>.</p>
<h3 id="annotated-pattern">Annotated pattern</h3>
<p>The annotated pattern <code>&lt;pat&gt; : &lt;typ&gt;</code> matches
value of <code>v</code> type <code>&lt;typ&gt;</code> against the
pattern <code>&lt;pat&gt;</code>.</p>
<p><code>&lt;pat&gt; : &lt;typ&gt;</code> is <em>not</em> a dynamic type
test, but is used to constrain the types of identifiers bound in
<code>&lt;pat&gt;</code>, e.g. in the argument pattern to a
function.</p>
<h3 id="option-pattern">Option pattern</h3>
<p>The option <code>? &lt;pat&gt;</code> matches a value of option type
<code>? &lt;typ&gt;</code>.</p>
<p>The match <em>fails</em> if the value is <code>null</code>. If the
value is <code>? v</code>, for some value <code>v</code>, then the
result of matching <code>? &lt;pat&gt;</code> is the result of matching
<code>v</code> against <code>&lt;pat&gt;</code>.</p>
<p>Conversely, the <code>null</code> literal pattern may be used to test
whether a value of option type is the value <code>null</code> and not
<code>? v</code> for some <code>v</code>.</p>
<h3 id="or-pattern">Or pattern</h3>
<p>The or pattern <code>&lt;pat1&gt; or &lt;pat2&gt;</code> is a
disjunctive pattern.</p>
<p>The result of matching <code>&lt;pat1&gt; or &lt;pat2&gt;</code>
against a value is the result of matching <code>&lt;pat1&gt;</code>, if
it succeeds, or the result of matching <code>&lt;pat2&gt;</code>, if the
first match fails.</p>
<p>(Note, an <code>or</code>-pattern may contain identifier
(<code>&lt;id&gt;</code>) patterns with the restriction that both
alternatives must bind the same set of identifiers. Each identifier's
type is the least upper bound of its type in <code>&lt;pat1&gt;</code>
and <code>&lt;pat2&gt;</code>.</p>
<h3 id="expression-declaration">Expression declaration</h3>
<p>The declaration <code>&lt;exp&gt;</code> has type <code>T</code>
provided the expression <code>&lt;exp&gt;</code> has type <code>T</code>
. It declares no bindings.</p>
<p>The declaration <code>&lt;exp&gt;</code> evaluates to the result of
evaluating <code>&lt;exp&gt;</code> (typically for
<code>&lt;exp&gt;</code>'s side-effect).</p>
<p>Note that if <code>&lt;exp&gt;</code> appears within a sequence of
declarations, but not as the last declaration of that sequence, then
<code>T</code> must be <code>()</code>.</p>
<!--
TBR
-->

<h3 id="let-declaration">Let declaration</h3>
<p>The <code>let</code> declaration
<code>let &lt;pat&gt; = &lt;exp&gt;</code> has type <code>T</code> and
declares the bindings in <code>&lt;pat&gt;</code> provided:</p>
<ul>
<li><p><code>&lt;exp&gt;</code> has type <code>T</code>, and</p></li>
<li><p><code>&lt;pat&gt;</code> has type <code>T</code>.</p></li>
</ul>
<p>The declaration <code>let &lt;pat&gt; = &lt;exp&gt;</code> evaluates
<code>&lt;exp&gt;</code> to a result <code>r</code>. If <code>r</code>
is <code>trap</code>, the declaration evaluates to <code>trap</code>. If
<code>r</code> is a value <code>v</code> then evaluation proceeds by
matching the value <code>v</code> against <code>&lt;pat&gt;</code>. If
matching fails, then the result is <code>trap</code>. Otherwise, the
result is <code>v</code> and the binding of all identifiers in
<code>&lt;pat&gt;</code> to their matching values in <code>v</code>.</p>
<p>All bindings declared by a <code>let</code> (if any) are
<em>immutable</em>.</p>
<h3 id="let-else-declaration">Let-else declaration</h3>
<p>The <code>let-else</code> declaration
<code>let &lt;pat&gt; = &lt;exp&gt; else &lt;block-or-exp&gt;</code> has
type <code>T</code> and declares the bindings in
<code>&lt;pat&gt;</code> provided:</p>
<ul>
<li><p><code>&lt;exp&gt;</code> has type <code>T</code>,</p></li>
<li><p><code>&lt;pat&gt;</code> has type <code>T</code>, and</p></li>
<li><p><code>&lt;block-or-exp&gt;</code> has type
<code>None</code>.</p></li>
</ul>
<p>The declaration
<code>let &lt;pat&gt; = &lt;exp&gt; else &lt;block-or-exp&gt;</code>
evaluates <code>&lt;exp&gt;</code> to a result <code>r</code>. If
<code>r</code> is <code>trap</code>, the declaration evaluates to
<code>trap</code>. If <code>r</code> is a value <code>v</code> then
evaluation proceeds by matching the value <code>v</code> against
<code>&lt;pat&gt;</code>. If matching succeeds, the result is
<code>v</code> and the binding of all identifiers in
<code>&lt;pat&gt;</code> to their matching values in <code>v</code>. If
matching fails, then evaluation continues with
<code>&lt;block-or-exp&gt;</code>, which, having type <code>None</code>,
cannot proceed to the end of the declaration but may still alter
control-flow to, for example <code>return</code> or <code>throw</code>
to exit an enclosing function, break` from an enclosing expression or
simply diverge.</p>
<p>All bindings declared by a <code>let-else</code> (if any) are
<em>immutable</em>.</p>
<h4 id="handling-pattern-match-failures">Handling pattern match
failures</h4>
<p>In the presence of refutable patterns, the pattern in a
<code>let</code> declaration may fail to match the value of its
expression. In such cases, the <code>let</code>-declaration will
evaluate to a trap. The compiler emits a warning for any
<code>let</code>-declaration than can trap due to pattern match
failure.</p>
<p>Instead of trapping, a user may want to explicitly handle pattern
match failures. The <code>let-else</code> declaration,
<code>let &lt;pat&gt; = &lt;exp&gt; else &lt;block-or-exp&gt;</code>,
has mostly identical static and dynamic semantics to <code>let</code>,
but diverts the program's control flow to
<code>&lt;block-or-exp&gt;</code> when pattern matching fails, allowing
recovery from failure. The <code>else</code> expression,
<code>&lt;block-or-exp&gt;</code>, must have type <code>None</code> and
typically exits the declaration using imperative control flow constructs
such as <code>throw</code>, <code>return</code>, <code>break</code> or
non-returning functions such as <code>Debug.trap(...)</code> (that all
produce a result of type <code>None</code>). Any compilation warning
that is produced for a <code>let</code> can be silenced by handling the
potential pattern-match failure using <code>let-else</code>.</p>
<h3 id="var-declaration">Var declaration</h3>
<p>The variable declaration
<code>var &lt;id&gt; (: &lt;typ&gt;)? = &lt;exp&gt;</code> declares a
<em>mutable</em> variable <code>&lt;id&gt;</code> with initial value
<code>&lt;exp&gt;</code>. The variable’s value can be updated by
assignment.</p>
<p>The declaration <code>var &lt;id&gt;</code> has type <code>()</code>
provided:</p>
<ul>
<li><p><code>&lt;exp&gt;</code> has type <code>T</code>; and</p></li>
<li><p>If the annotation <code>(:&lt;typ&gt;)?</code> is present, then
<code>T</code> == <code>&lt;typ&gt;</code>.</p></li>
</ul>
<p>Within the scope of the declaration, <code>&lt;id&gt;</code> has type
<code>var T</code> (see <a href="#assignment">Assignment</a>).</p>
<p>Evaluation of
<code>var &lt;id&gt; (: &lt;typ&gt;)? = &lt;exp&gt;</code> proceeds by
evaluating <code>&lt;exp&gt;</code> to a result <code>r</code>. If
<code>r</code> is <code>trap</code>, the declaration evaluates to
<code>trap</code>. Otherwise, the <code>r</code> is some value
<code>v</code> that determines the initial value of mutable variable
<code>&lt;id&gt;</code>. The result of the declaration is
<code>()</code> and <code>&lt;id&gt;</code> is bound to a fresh location
that contains <code>v</code>.</p>
<h3 id="type-declaration">Type declaration</h3>
<p>The declaration
<code>type &lt;id&gt; &lt;typ-params&gt;? = &lt;typ&gt;</code> declares
a new type constructor <code>&lt;id&gt;</code>, with optional type
parameters <code>&lt;typ-params&gt;</code> and definition
<code>&lt;typ&gt;</code>.</p>
<p>The declaration
<code>type C&lt; X0 &lt;: T0, …​, Xn &lt;: Tn &gt; = U</code> is
well-formed provided:</p>
<ul>
<li><p>type parameters <code>X0</code>, …​, <code>Xn</code> are distinct,
and</p></li>
<li><p>assuming the constraints <code>X0 &lt;: T0</code>, …​,
<code>Xn &lt;: Tn</code>:</p></li>
<li><p>constraints <code>T0</code>, …​, <code>Tn</code> are
well-formed.</p></li>
<li><p>definition <code>U</code> is well-formed.</p></li>
<li><p>it is productive (see <a
href="#productivity">Productivity</a>).</p></li>
<li><p>it is non-expansive (see <a
href="#expansiveness">Expansiveness</a>).</p></li>
</ul>
<p>In scope of the declaration
<code>type C&lt; X0&lt;:T0, …​, Xn &lt;: Tn &gt; = U</code>, any
well-formed type <code>C&lt; U0, …​, Un &gt;</code> is equivalent to its
expansion <code>U [ U0/X0, …​, Un/Xn ]</code>. Distinct type expressions
that expand to identical types are inter-changeable, regardless of any
distinction between type constructor names. In short, the equivalence
between types is structural, not nominal.</p>
<h4 id="productivity">Productivity</h4>
<p>A type is <em>productive</em> if recursively expanding any outermost
type constructor in its definition eventually produces a type other than
the application of a type constructor.</p>
<p>Motoko requires all type declarations to be productive.</p>
<p>For example, the type definitions:</p>
<pre class="motoko"><code>  type Person = { first : Text; last : Text };

  type List&lt;T&gt; = ?(T, List&lt;T&gt;);

  type Fst&lt;T, U&gt; = T;

  type Ok&lt;T&gt; = Fst&lt;Any, Ok&lt;T&gt;&gt;;</code></pre>
<p>are all productive and legal.</p>
<p>But the type definitions,</p>
<pre class="motoko"><code>  type C = C;

  type D&lt;T, U&gt; = D&lt;U, T&gt;;

  type E&lt;T&gt; = F&lt;T&gt;;
  type F&lt;T&gt; = E&lt;T&gt;;

  type G&lt;T&gt; = Fst&lt;G&lt;T&gt;, Any&gt;;</code></pre>
<p>are all non-productive, since each definition will enter a loop after
one or more expansions of its body.</p>
<h4 id="expansiveness">Expansiveness</h4>
<p>A set of mutually recursive type or class declarations will be
rejected if the set is <em>expansive</em>.</p>
<p>Expansiveness is a syntactic criterion. To determine whether a set of
singly or mutually recursive type definitions, say</p>
<pre class="motoko"><code>  type C&lt;...,Xi,...&gt; = T;
  ...
  type D&lt;...,Yj,...&gt; = U;</code></pre>
<p>is expansive, construct a directed graph whose vertices are the
formal type parameters (identified by position), <code>C#i</code>, with
the following <code>{0,1}</code>-labeled edges:</p>
<ul>
<li><p>For each occurrence of parameter <code>C#i</code> as immediate,
<code>j</code>-th argument to type <code>D&lt;…​,C#i,…​&gt;</code>, add a
<em>non-expansive</em>, <code>0</code>-labeled
edge,<code>C#i -0-&gt; D#j</code>.</p></li>
<li><p>For each occurrence of parameter <code>C#i</code> as a proper
sub-expression of the <code>j</code>-th argument to type
<code>D&lt;…​,T[C#i],..&gt;</code> add an <em>expansive</em>
<code>1</code>-labeled edge, <code>C#i -1-&gt; D#j</code>.</p></li>
</ul>
<p>The graph is expansive if, and only if, it contains a cycle with at
least one expansive edge.</p>
<p>For example, the type definition:</p>
<pre class="motoko"><code>  type List&lt;T&gt; = ?(T, List&lt;T&gt;);</code></pre>
<p>that recursively instantiates <code>List</code> at the same parameter
<code>T</code>, is non-expansive and accepted, but the similar looking
definition:</p>
<pre class="motoko"><code>  type Seq&lt;T&gt; = ?(T, Seq&lt;[T]&gt;);</code></pre>
<p>that recursively instantiates <code>Seq</code> with a larger type,
<code>[T]</code>, containing <code>T</code>, is <em>expansive</em> and
rejected.</p>
<ul>
<li><p>Type <code>List&lt;T&gt;</code> is non-expansive because its
graph, <code>{ List#0 -0-&gt; List#0 }</code>, though cyclic, has no
expansive edge.</p></li>
<li><p>Type <code>Seq&lt;T&gt;</code>, on the other hand, is expansive,
because its graph, <code>{ Seq#0 -1-&gt; Seq#0 }</code>, has a cycle
that includes an expansive edge.</p></li>
</ul>
<h3 id="object-declaration">Object declaration</h3>
<p>Declaration
<code>&lt;sort&gt; &lt;id&gt;? (: &lt;typ&gt;)? =? &lt;obj-body&gt;</code>,
where <code>&lt;obj-body&gt;</code> is of the form
<code>{ &lt;dec-field&gt;;* }</code>, declares an object with optional
identifier <code>&lt;id&gt;</code> and zero or more fields
<code>&lt;dec-field&gt;;*</code>. Fields can be declared with
<code>public</code> or <code>private</code> visibility; if the
visibility is omitted, it defaults to <code>private</code>.</p>
<p>The qualifier <code>&lt;sort&gt;</code> (one of <code>actor</code>,
<code>module</code> or <code>object</code>) specifies the <em>sort</em>
of the object’s type. The sort imposes restrictions on the types of the
public object fields.</p>
<p>Let
<code>T = &lt;sort&gt; { [var0] id0 : T0, …​ , [varn] idn : T0 }</code>
denote the type of the object. Let <code>&lt;dec&gt;;*</code> be the
sequence of declarations embedded in <code>&lt;dec-field&gt;;*</code>.
The object declaration has type <code>T</code> provided that:</p>
<ol type="1">
<li><p>type <code>T</code> is well-formed for sort <code>sort</code>,
and</p></li>
<li><p>under the assumption that <code>&lt;id&gt; : T</code>,</p>
<ul>
<li><p>the sequence of declarations <code>&lt;dec&gt;;*</code> has type
<code>Any</code> and declares the disjoint sets of private and public
identifiers, <code>Id_private</code> and <code>Id_public</code>
respectively, with types <code>T(id)</code> for <code>id</code> in
<code>Id == Id_private union Id_public</code>, and</p></li>
<li><p><code>{ id0, …​, idn } == Id_public</code>, and</p></li>
<li><p>for all <code>i in 0 &lt;= i &lt;= n</code>,
<code>[vari] Ti == T(idi)</code>.</p></li>
</ul></li>
<li><p>If <code>&lt;sort&gt;</code> is <code>module</code>, then the
declarations in <code>&lt;dec&gt;;*</code> must be <em>static</em> (see
<a href="#static-declarations">Static declarations</a>).</p></li>
</ol>
<p>Note that requirement 1. imposes further constraints on the field
types of <code>T</code>. In particular, if the sort is
<code>actor</code> then:</p>
<ul>
<li>all public fields must be non-<code>var</code> (immutable)
<code>shared</code> functions (the public interface of an actor can only
provide asynchronous messaging via shared functions);</li>
</ul>
<p>Because actor construction is asynchronous, an actor declaration can
only occur in an asynchronous context (i.e. in the body of a
(non-<code>&lt;query&gt;</code>) <code>shared</code> function,
<code>async</code> expression or <code>async*</code> expression).</p>
<p>Evaluation of
<code>&lt;sort&gt;? &lt;id&gt;? =? { &lt;dec-field&gt;;* }</code>
proceeds by binding <code>&lt;id&gt;</code> (if present), to the
eventual value <code>v</code>, and evaluating the declarations in
<code>&lt;dec&gt;;*</code>. If the evaluation of
<code>&lt;dec&gt;;*</code> traps, so does the object declaration.
Otherwise, <code>&lt;dec&gt;;*</code> produces a set of bindings for
identifiers in <code>Id</code>. let <code>v0</code>, …​, <code>vn</code>
be the values or locations bound to identifiers
<code>&lt;id0&gt;</code>, …​, <code>&lt;idn&gt;</code>. The result of the
object declaration is the object
<code>v == sort { &lt;id0&gt; = v1, …​, &lt;idn&gt; = vn}</code>.</p>
<p>If <code>&lt;id&gt;?</code> is present, the declaration binds
<code>&lt;id&gt;</code> to <code>v</code>. Otherwise, it produces the
empty set of bindings.</p>
<p>If <code>(: &lt;typ&gt;)?</code> is present, then <code>T</code> must
be a subtype of <code>&lt;typ&gt;</code>.</p>
<p>:::danger</p>
<p>Actor declaration is (implicitly) asynchronous and the state of the
enclosing actor may change due to concurrent processing of other
incoming actor messages. It is the programmer’s responsibility to guard
against non-synchronized state changes.</p>
<p>:::</p>
<h4 id="static-declarations">Static declarations</h4>
<p>A declaration is <em>static</em> if it is:</p>
<ul>
<li><p>a <code>type</code> declaration, or</p></li>
<li><p>a <code>class</code> declaration, or</p></li>
<li><p>a <code>let</code> declaration with a static pattern and a static
expression, or</p></li>
<li><p>a module, function or object declaration that desugars to a
static <code>let</code> declaration, or</p></li>
<li><p>a static expression.</p></li>
</ul>
<p>An expression is <em>static</em> if it is:</p>
<ul>
<li><p>a literal expression, or</p></li>
<li><p>a tuple of static expressions, or</p></li>
<li><p>an object of static expressions, or</p></li>
<li><p>a variant or option with a static expression, or</p></li>
<li><p>an immutable array, or</p></li>
<li><p>field access and projection from a static expression, or</p></li>
<li><p>a module expression, or</p></li>
<li><p>a function expression, or</p></li>
<li><p>a static declaration, or</p></li>
<li><p>an <code>ignore</code> of a static expression, or</p></li>
<li><p>a block, all of whose declarations are static, or</p></li>
<li><p>a type annotation with a static expression.</p></li>
</ul>
<p>A pattern is <em>static</em> if it is:</p>
<ul>
<li><p>an identifier, or</p></li>
<li><p>a wildcard, or</p></li>
<li><p>a tuple of static patterns, or</p></li>
<li><p>type annotation with a static pattern.</p></li>
</ul>
<!--
why not record patterns?
-->

<p>Static phrases are designed to be side-effect free, allowing the
coalescing of duplicate library imports (a.k.a deduplication).</p>
<h3 id="function-declaration">Function declaration</h3>
<p>The function declaration
<code>&lt;shared-pat&gt;? func &lt;id&gt;? &lt;typ-params&gt;? &lt;pat&gt; (: &lt;typ&gt;)? =? &lt;exp&gt;</code>
is syntactic sugar for a named <code>let</code> or anonymous declaration
of a function expression.</p>
<p>That is, when <code>&lt;id&gt;?</code> is present and the function is
named:</p>
<pre class="bnf"><code>&lt;shared-pat&gt;? func &lt;id&gt; &lt;typ-params&gt;? &lt;pat&gt; (: &lt;typ&gt;)? =? &lt;block-or-exp&gt; :=
  let &lt;id&gt; = &lt;shared-pat&gt;? func &lt;typ-params&gt;? &lt;pat&gt; (: &lt;typ&gt;)? =? &lt;block-or-exp&gt;</code></pre>
<p>But when <code>&lt;id&gt;?</code> is absent and the function is
anonymous:</p>
<pre class="bnf"><code>&lt;shared-pat&gt;? func &lt;typ-params&gt;? &lt;pat&gt; (: &lt;typ&gt;)? =? &lt;block-or-exp&gt; :=
  &lt;shared-pat&gt;? func &lt;typ-params&gt;? &lt;pat&gt; (: &lt;typ&gt;)? =? &lt;block-or-exp&gt;</code></pre>
<p>Named function definitions support recursion (a named function can
call itself).</p>
<p>:::note</p>
<p>In compiled code, <code>shared</code> functions can only appear as
public actor fields.</p>
<p>:::</p>
<h3 id="class-declaration">Class declaration</h3>
<p>The <em>class</em> declaration
<code>&lt;shared-pat&gt;? &lt;sort&gt;? class &lt;id&gt;? &lt;typ-params&gt;? &lt;pat&gt; (: &lt;typ&gt;)? &lt;class-body&gt;</code>
is sugar for pair of a type and function declaration:</p>
<pre class="bnf"><code>&lt;shared-pat&gt;? &lt;sort&gt;? class &lt;id&gt; &lt;typ-params&gt;? &lt;pat&gt; (: &lt;typ&gt;)? &lt;class-body&gt; :=
  type &lt;id&gt; &lt;typ-params&gt; = &lt;sort&gt; { &lt;typ-field&gt;;* };
  &lt;shared-pat&gt;? func &lt;id&gt; &lt;typ-params&gt;? &lt;pat&gt; : async? &lt;id&gt; &lt;typ-args&gt; =
    async? &lt;sort&gt; &lt;id_this&gt;? &lt;obj-body&gt;</code></pre>
<p>where:</p>
<ul>
<li><p><code>&lt;shared-pat&gt;?</code>, when present, requires
<code>&lt;sort&gt;</code> == <code>actor</code>, and provides access to
the <code>caller</code> of an <code>actor</code> constructor,
and</p></li>
<li><p><code>&lt;typ-args&gt;?</code> is the sequence of type
identifiers bound by <code>&lt;typ-params&gt;?</code> (if any),
and</p></li>
<li><p><code>&lt;typ-field&gt;;*</code> is the set of public field types
inferred from <code>&lt;dec-field&gt;;*</code>.</p></li>
<li><p><code>&lt;obj-body&gt;</code> is the object body of
<code>&lt;class-body&gt;</code>.</p></li>
<li><p><code>&lt;id_this&gt;?</code> is the optional <em>this</em>
(a.k.a <em>self</em>), parameter of
<code>&lt;class-body&gt;</code>.</p></li>
<li><p><code>async?</code> is present, if only if,
<code>&lt;sort&gt;</code> == <code>actor</code>.</p></li>
</ul>
<p>Note <code>&lt;shared-pat&gt;?</code> must not be of the form
<code>shared &lt;query&gt; &lt;pat&gt;?</code>: a constructor, unlike a
function, cannot be a <code>query</code> or
<code>composite query</code>.</p>
<p>An absent <code>&lt;shared-pat&gt;?</code> defaults to
<code>shared</code> when <code>sort</code> = <code>actor</code>.</p>
<p>If <code>sort</code> is <code>actor</code>, then:</p>
<ul>
<li><p><code>&lt;typ-args&gt;?</code> must be absent or empty
(<code>actor</code> classes cannot have type parameters);</p></li>
<li><p><code>&lt;pat&gt;</code>'s type must be shared (see <a
href="#sharability">Sharability</a>).</p></li>
<li><p><code>(: &lt;typ&gt;)?</code>, if present, must be of the form
<code>: async T</code> for some actor type <code>T</code> (actor
instantiation is asynchronous).</p></li>
</ul>
<p>If <code>(: &lt;typ&gt;)</code> is present, then the type
<code>&lt;async?&gt; &lt;sort&gt; {  &lt;typ_field&gt;;* }</code> must
be a subtype of the annotation <code>&lt;typ&gt;</code>. In particular,
the annotation is used only to check, but not affect, the inferred type
of function <code>&lt;id&gt;</code>.</p>
<p>The class declaration has the same type as function
<code>&lt;id&gt;</code> and evaluates to the function value
<code>&lt;id&gt;</code>.</p>
<h3 id="identifiers-1">Identifiers</h3>
<p>The identifier expression <code>&lt;id&gt;</code> has type
<code>T</code> provided <code>&lt;id&gt;</code> is in scope, defined and
declared with explicit or inferred type <code>T</code>.</p>
<p>The expression <code>&lt;id&gt;</code> evaluates to the value bound
to <code>&lt;id&gt;</code> in the current evaluation environment.</p>
<h3 id="literals-1">Literals</h3>
<p>A literal has type <code>T</code> only when its value is within the
prescribed range of values of type <code>T</code>.</p>
<p>The literal (or constant) expression <code>&lt;lit&gt;</code>
evaluates to itself.</p>
<h3 id="unary-operators-1">Unary operators</h3>
<p>The unary operator <code>&lt;unop&gt; &lt;exp&gt;</code> has type
<code>T</code> provided:</p>
<ul>
<li><p><code>&lt;exp&gt;</code> has type <code>T</code>, and</p></li>
<li><p>The category of <code>&lt;unop&gt;</code> is a category of
<code>T</code>.</p></li>
</ul>
<p>The unary operator expression <code>&lt;unop&gt; &lt;exp&gt;</code>
evaluates <code>&lt;exp&gt;</code> to a result. If the result is a value
<code>v</code>, it returns the result of <code>&lt;unop&gt; v</code>. If
the result is <code>trap</code>, the entire expression results in
<code>trap</code>.</p>
<h3 id="binary-operators">Binary operators</h3>
<p>The binary operator expression
<code>&lt;exp1&gt; &lt;binop&gt; &lt;exp2&gt;</code> has type
<code>T</code> provided:</p>
<ul>
<li><p><code>&lt;exp1&gt;</code> has type <code>T</code>, and</p></li>
<li><p><code>&lt;exp2&gt;</code> has type <code>T</code>, and</p></li>
<li><p>The category of <code>&lt;binop&gt;</code> is a category of
<code>T</code>.</p></li>
</ul>
<p>The binary operator expression
<code>&lt;exp1&gt; &lt;binop&gt; &lt;exp2&gt;</code> evaluates
<code>exp1</code> to a result <code>r1</code>. If <code>r1</code> is
<code>trap</code>, the expression results in <code>trap</code>.</p>
<p>Otherwise, <code>exp2</code> is evaluated to a result
<code>r2</code>. If <code>r2</code> is <code>trap</code>, the expression
results in <code>trap</code>.</p>
<p>Otherwise, <code>r1</code> and <code>r2</code> are values
<code>v1</code> and <code>v2</code> and the expression returns the
result of <code>v1 &lt;binop&gt; v2</code>.</p>
<h3 id="relational-operators-1">Relational operators</h3>
<p>The relational expression
<code>&lt;exp1&gt; &lt;relop&gt; &lt;exp2&gt;</code> has type
<code>Bool</code> provided:</p>
<ul>
<li><p><code>&lt;exp1&gt;</code> has type <code>T</code>, and</p></li>
<li><p><code>&lt;exp2&gt;</code> has type <code>T</code>, and</p></li>
<li><p><code>&lt;relop&gt;</code> is equality <code>==</code> or
inequality <code>!=</code>, <code>T</code> is <em>shared</em>, and
<code>T</code> is the least type such that <code>&lt;exp1&gt;</code> and
<code>&lt;exp2&gt;</code> have type <code>T</code>;</p></li>
<li><p>the category O (Ordered) is a category of <code>T</code> and
<code>&lt;relop&gt;</code>; or</p></li>
</ul>
<p>The binary operator expression
<code>&lt;exp1&gt; &lt;relop&gt; &lt;exp2&gt;</code> evaluates
<code>&lt;exp1&gt;</code> to a result <code>r1</code>. If
<code>r1</code> is <code>trap</code>, the expression results in
<code>trap</code>.</p>
<p>Otherwise, <code>exp2</code> is evaluated to a result
<code>r2</code>. If <code>r2</code> is <code>trap</code>, the expression
results in <code>trap</code>.</p>
<p>Otherwise, <code>r1</code> and <code>r2</code> are values
<code>v1</code> and <code>v2</code> and the expression returns the
Boolean result of <code>v1 &lt;relop&gt; v2</code>.</p>
<p>For equality and inequality, the meaning of
<code>v1 &lt;relop&gt; v2</code> depends on the compile-time, static
choice of <code>T</code> (not the run-time types of <code>v1</code> and
<code>v2</code>, which, due to subtyping, may be more precise).</p>
<h3 id="pipe-operators-and-placeholder-expressions">Pipe operators and
placeholder expressions</h3>
<p>The pipe expression <code>&lt;exp1&gt; |&gt; &lt;exp2&gt;</code>
binds the value of <code>&lt;exp1&gt;</code> to the special placeholder
expression <code>_</code>, that can be referenced in
<code>&lt;exp2&gt;</code> (and recursively in
<code>&lt;exp1&gt;</code>). Referencing the placeholder expression
outside of a pipe operation is a compile-time error.</p>
<p>The pipe expression <code>&lt;exp1&gt; |&gt; &lt;exp2&gt;</code> is
just syntactic sugar for a <code>let</code> binding to a placeholder
identifier, <code>p</code>:</p>
<pre class="bnf"><code>do { let p = &lt;exp1&gt;; &lt;exp2&gt; }</code></pre>
<p>The placeholder expression <code>_</code> is just syntactic sugar for
the expression referencing the placeholder identifier:</p>
<pre class="bnf"><code>p</code></pre>
<p>The placeholder identifier, <code>p</code>, is a fixed, reserved
identifier that cannot be bound by any other expression or pattern other
than a pipe operation, and can only be referenced using the placeholder
expression <code>_</code>.</p>
<p><code>|&gt;</code> has lowest precedence amongst all operators except
<code>:</code> and associates to the left.</p>
<p>Judicious use of the pipe operator allows one to express a more
complicated nested expression by piping arguments of that expression
into their nested positions within that expression.</p>
<p>For example:</p>
<pre class="motoko"><code>Iter.range(0, 10) |&gt;
  Iter.toList _ |&gt;
    List.filter&lt;Nat&gt;(_, func n { n % 3 == 0 }) |&gt;
      { multiples = _ };</code></pre>
<p>may, according to taste, be a more readable rendition of:</p>
<pre class="motoko"><code>{ multiples =
   List.filter&lt;Nat&gt;(
     Iter.toList(Iter.range(0, 10)),
     func n { n % 3 == 0 }) };</code></pre>
<p>Above, each occurence of <code>_</code> refers to the value of the
left-hand-size of the nearest enclosing pipe operation, after
associating nested pipes to the left.</p>
<p>Note that the evaluation order of the two examples is different, but
consistently left-to-right.</p>
<p>:::note</p>
<p>Although syntactically identical, the placeholder expression is
semantically distinct from, and should not be confused with, the
wildcard pattern <code>_</code>. Occurrences of the forms can be
distinguished by their syntactic role as pattern or expression.</p>
<p>:::</p>
<h3 id="tuples">Tuples</h3>
<p>Tuple expression <code>(&lt;exp1&gt;, …​, &lt;expn&gt;)</code> has
tuple type <code>(T1, …​, Tn)</code>, provided <code>&lt;exp1&gt;</code>,
…​, <code>&lt;expn&gt;</code> have types <code>T1</code>, …​,
<code>Tn</code>.</p>
<p>The tuple expression <code>(&lt;exp1&gt;, …​, &lt;expn&gt;)</code>
evaluates the expressions <code>exp1</code> …​ <code>expn</code> in
order, trapping as soon as some expression <code>&lt;expi&gt;</code>
traps. If no evaluation traps and <code>exp1</code>, …​,
<code>&lt;expn&gt;</code> evaluate to values
<code>v1</code>,…​,<code>vn</code> then the tuple expression returns the
tuple value <code>(v1, …​ , vn)</code>.</p>
<p>The tuple projection <code>&lt;exp&gt; . &lt;nat&gt;</code> has type
<code>Ti</code> provided <code>&lt;exp&gt;</code> has tuple type
<code>(T1, …​, Ti, …​, Tn)</code>, <code>&lt;nat&gt;</code> ==
<code>i</code> and <code>1 &lt;= i &lt;= n</code>.</p>
<p>The projection <code>&lt;exp&gt; . &lt;nat&gt;</code> evaluates
<code>&lt;exp&gt;</code> to a result <code>r</code>. If <code>r</code>
is <code>trap</code>, then the result is <code>trap</code>. Otherwise,
<code>r</code> must be a tuple <code>(v1,…​,vi,…​,vn)</code> and the
result of the projection is the value <code>vi</code>.</p>
<p>The empty tuple expression <code>()</code> is called the <em>unit
value</em>.</p>
<h3 id="option-expressions">Option expressions</h3>
<p>The option expression <code>? &lt;exp&gt;</code> has type
<code>? T</code> provided <code>&lt;exp&gt;</code> has type
<code>T</code>.</p>
<p>The literal <code>null</code> has type <code>Null</code>. Since
<code>Null &lt;: ? T</code> for any <code>T</code>, literal
<code>null</code> also has type <code>? T</code> and signifies the
"missing" value at type <code>? T</code>.</p>
<h3 id="variant-injection">Variant injection</h3>
<p>The variant injection <code># &lt;id&gt; &lt;exp&gt;</code> has
variant type <code>{# id T}</code> provided:</p>
<ul>
<li><code>&lt;exp&gt;</code> has type <code>T</code>.</li>
</ul>
<p>The variant injection <code># &lt;id&gt;</code> is just syntactic
sugar for <code># &lt;id&gt; ()</code>.</p>
<p>The variant injection <code># &lt;id&gt; &lt;exp&gt;</code> evaluates
<code>&lt;exp&gt;</code> to a result <code>r</code>. If <code>r</code>
is <code>trap</code>, then the result is <code>trap</code>. Otherwise,
<code>r</code> must be a value <code>v</code> and the result of the
injection is the tagged value <code># &lt;id&gt; v</code>.</p>
<p>The tag and contents of a variant value can be tested and accessed
using a <a href="#variant-pattern">variant pattern</a>.</p>
<h3 id="objects">Objects</h3>
<p>Objects can be written in literal form
<code>{ &lt;exp-field&gt;;* }</code>, consisting of a list of expression
fields:</p>
<pre class="bnf"><code>&lt;exp-field&gt; ::=                                object expression fields
  var? &lt;id&gt; (: &lt;typ&gt;) = &lt;exp&gt;                    field
  var? &lt;id&gt; (: &lt;typ&gt;)                            punned field</code></pre>
<p>Such an object literal, sometimes called a <em>record</em>, is
equivalent to the object declaration
<code>object { &lt;dec-field&gt;;* }</code> where the declaration fields
are obtained from the expression fields by prefixing each of them with
<code>public let</code>, or just <code>public</code> in case of
<code>var</code> fields. However, unlike declarations, the field list
does not bind each <code>&lt;id&gt;</code> as a local name within the
literal, i.e., the field names are <em>not</em> in scope in the field
expressions.</p>
<p>Object expressions support <em>punning</em> for concision. A punned
field <code>&lt;id&gt;</code> is shorthand for
<code>&lt;id&gt; = &lt;id&gt;</code>; Similarly, a typed, punned field
<code>&lt;id&gt; : &lt;typ&gt;</code> is short-hand for
<code>&lt;id&gt; = &lt;id&gt; : &lt;typ&gt;</code>. Both associate the
field named <code>&lt;id&gt;</code> with the value of the identifier
<code>&lt;id&gt;</code>.</p>
<h3 id="object-combinationextension">Object combination/extension</h3>
<p>Objects can be combined and/or extended using the <code>and</code>
and <code>with</code> keywords.</p>
<p>A record expression
<code>{ &lt;exp&gt; (and &lt;exp&gt;)* (with &lt;exp-field&gt;;+)? }</code>
merges the objects (or modules) specified as <em>base</em> expressions,
and augments the result to also contain the specified fields. The
<code>with &lt;exp-field&gt;;+</code> clause can be omitted when at
least two bases appear and none have common field labels. Thus the field
list serves to:</p>
<ul>
<li>disambiguate field labels occurring more than once in the
bases,</li>
<li>define new fields,</li>
<li>override existing fields and their types, and</li>
<li>add new <code>var</code> fields</li>
<li>redefine existing <code>var</code> fields from some base to prevent
aliasing.</li>
</ul>
<p>The resulting type is determined by the bases' (and explicitly given
fields') static type.</p>
<p>Any <code>var</code> field from some base must be overwritten in the
explicit field list. This prevents introducing aliases of
<code>var</code> fields.</p>
<p>The record expression
<code>{ &lt;exp1&gt; and ... &lt;expn&gt; with &lt;exp-field1&gt;; ... &lt;exp_fieldn&gt;; }</code>
has type <code>T</code> provided:</p>
<ul>
<li><p>The record
<code>{ &lt;exp-field1&gt;; ... &lt;exp_fieldm&gt;; }</code> has record
type
<code>{ field_tys } == { var? &lt;id1&gt; : U1; ... var? &lt;idm&gt; : Um }</code>.</p></li>
<li><p>Let <code>newfields == { &lt;id1&gt; , ..., &lt;idm&gt; }</code>
be the set of new field names.</p></li>
<li><p>Considering value fields:</p>
<ul>
<li>Base expression <code>&lt;expi&gt;</code> has object or module type
<code>sorti { field_tysi } == sorti { var? &lt;idi1&gt; : Ti1, …​, var? &lt;idik&gt; : Tik }</code>
where <code>sorti &lt;&gt; Actor</code>.</li>
</ul>
<p>Let <code>fields(i) == { &lt;idi1&gt;, ..., &lt;idik&gt; }</code> be
the set of static field names of base <code>i</code>. Then</p>
<ul>
<li><code>fields(i)</code> is disjoint from <code>newfields</code>
(possibly by applying subtyping to the type of
<code>&lt;expi&gt;</code>);</li>
<li>no field in <code>field_tysi</code> is a <code>var</code>
field;</li>
<li><code>fields(i)</code> is disjoint from <code>fields(j)</code> for
<code>j &lt; i</code>.</li>
</ul></li>
<li><p>Considering type fields:</p>
<ul>
<li>Base expression <code>&lt;expi&gt;</code> has object or module type
<code>sorti { typ_fieldsi } == sorti { type &lt;idj1&gt; = … , …, type &lt;idik&gt; = … }</code>
where <code>sorti &lt;&gt; Actor</code>.</li>
<li><code>typ_fieldsi</code> <em>agrees</em> with
<code>typ_fieldsj</code> for <code>j &lt; i</code>.</li>
</ul></li>
<li><p><code>T</code> is
<code>{ typ_fieldsi fields_tys1 ... typ_fieldsm fields_tysm field_tys }</code>.</p></li>
</ul>
<p>Here, two sequences of type fields <em>agree</em> only when any two
type fields of the same name in each sequence have equivalent
definitions.</p>
<!--
Note that the case for type fields is simpler than the value fields case only because the clause `with <exp-field1>; ... <exp_fieldn>` cannot contain type fields.
-->

<p>The record expression
<code>{ &lt;exp1&gt; and ... &lt;expn&gt; with &lt;exp-field1&gt;; ... &lt;exp_fieldm&gt;; }</code>
evaluates records <code>&lt;exp1&gt;</code> through
<code>&lt;expn&gt;</code> and
<code>{ exp-field1; ... &lt;exp_fieldm }</code> to results
<code>r1</code> through <code>rn</code> and <code>r</code>, trapping on
the first result that is a trap. If none of the expressions produces a
trap, the results are objects <code>sort1 { f1 }</code>,
<code>sortn { fn }</code> and <code>object { f }</code>, where
<code>f1</code> ... <code>fn</code> and <code>f</code> are maps from
identifiers to values or mutable locations.</p>
<p>The result of the entire expression is the value
<code>object { g }</code> where <code>g</code> is the partial map with
domain <code>fields(1) union fields(n) union newfields</code> mapping
identifiers to unique values or locations such that
<code>g(&lt;id&gt;) = fi(&lt;id&gt;)</code> if <code>&lt;id&gt;</code>
is in <code>fields(i)</code>, for some <code>i</code>, or
<code>f(&lt;id&gt;)</code> if <code>&lt;id&gt;</code> is in
<code>newfields</code>.</p>
<h3 id="object-projection-member-access">Object projection (member
access)</h3>
<p>The object projection <code>&lt;exp&gt; . &lt;id&gt;</code> has type
<code>var? T</code> provided <code>&lt;exp&gt;</code> has object type
<code>sort { var1? &lt;id1&gt; : T1, …​, var? &lt;id&gt; : T, …​, var? &lt;idn&gt; : Tn }</code>
for some sort <code>sort</code>.</p>
<p>The object projection <code>&lt;exp&gt; . &lt;id&gt;</code> evaluates
<code>&lt;exp&gt;</code> to a result <code>r</code>. If <code>r</code>
is <code>trap</code>, then the result is <code>trap</code>. Otherwise,
<code>r</code> must be an object value
<code>{ &lt;id1&gt; = v1,…​, id = v, …​, &lt;idm&gt; = vm }</code> and the
result of the projection is the value <code>w</code> obtained from value
or location <code>v</code> in field <code>id</code>.</p>
<p>If <code>var</code> is absent from <code>var? T</code> then the value
<code>w</code> is just the value <code>v</code> of immutable field
<code>&lt;id&gt;</code>, otherwise:</p>
<ul>
<li><p>if the projection occurs as the target of an assignment
expression then <code>w</code> is just <code>v</code>, the mutable
location in field <code>&lt;id&gt;</code>.</p></li>
<li><p>otherwise, <code>w</code> (of type <code>T</code>) is the value
currently stored at the mutable location <code>v</code> in field
<code>&lt;id&gt;</code>.</p></li>
</ul>
<h3 id="special-member-access">Special member access</h3>
<p>The iterator access <code>&lt;exp&gt; . &lt;id&gt;</code> has type
<code>T</code> provided <code>&lt;exp&gt;</code> has type
<code>U</code>, and <code>U</code>,<code>&lt;id&gt;</code> and
<code>T</code> are related by a row of the following table:</p>
<table>
<tbody>
<tr class="odd">
<td>U</td>
<td><code>&lt;id&gt;</code></td>
<td>T</td>
<td>Description</td>
</tr>
<tr class="even">
<td><code>Text</code></td>
<td><code>size</code></td>
<td><code>Nat</code></td>
<td>size (or length) in characters</td>
</tr>
<tr class="odd">
<td><code>Text</code></td>
<td><code>chars</code></td>
<td><code>{ next: () -&gt; Char? }</code></td>
<td>character iterator, first to last</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>Blob</code></td>
<td><code>size</code></td>
<td><code>Nat</code></td>
<td>size in bytes</td>
</tr>
<tr class="even">
<td><code>Blob</code></td>
<td><code>vals</code></td>
<td><code>{ next: () -&gt; Nat8? }</code></td>
<td>byte iterator, first to last</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>[var? T]</code></td>
<td><code>size</code></td>
<td><code>Nat</code></td>
<td>number of elements</td>
</tr>
<tr class="odd">
<td><code>[var? T]</code></td>
<td><code>get</code></td>
<td><code>Nat -&gt; T</code></td>
<td>indexed read function</td>
</tr>
<tr class="even">
<td><code>[var? T]</code></td>
<td><code>keys</code></td>
<td><code>{ next: () -&gt; Nat? }</code></td>
<td>index iterator, by ascending index</td>
</tr>
<tr class="odd">
<td><code>[var? T]</code></td>
<td><code>vals</code></td>
<td><code>{ next: () -&gt; T? }</code></td>
<td>value iterator, by ascending index</td>
</tr>
<tr class="even">
<td><code>[var T]</code></td>
<td><code>put</code></td>
<td><code>(Nat, T) -&gt; ()</code></td>
<td>indexed write function (mutable arrays only)</td>
</tr>
</tbody>
</table>
<p>The projection <code>&lt;exp&gt; . &lt;id&gt;</code> evaluates
<code>&lt;exp&gt;</code> to a result <code>r</code>. If <code>r</code>
is <code>trap</code>, then the result is <code>trap</code>. Otherwise,
<code>r</code> must be a value of type <code>U</code> and the result of
the projection is a value of type <code>T</code> whose semantics is
given by the Description column of the previous table.</p>
<p>:::note</p>
<p>the <code>chars</code>, <code>vals</code>, <code>keys</code> and
<code>vals</code> members produce stateful <strong>iterator
objects</strong> than can be consumed by <code>for</code> expressions
(see <a href="#for">For</a>).</p>
<p>:::</p>
<h3 id="assignment">Assignment</h3>
<p>The assignment <code>&lt;exp1&gt; := &lt;exp2&gt;</code> has type
<code>()</code> provided:</p>
<ul>
<li><p><code>&lt;exp1&gt;</code> has type <code>var T</code>,
and</p></li>
<li><p><code>&lt;exp2&gt;</code> has type <code>T</code>.</p></li>
</ul>
<p>The assignment expression <code>&lt;exp1&gt; := &lt;exp2&gt;</code>
evaluates <code>&lt;exp1&gt;</code> to a result <code>r1</code>. If
<code>r1</code> is <code>trap</code>, the expression results in
<code>trap</code>.</p>
<p>Otherwise, <code>exp2</code> is evaluated to a result
<code>r2</code>. If <code>r2</code> is <code>trap</code>, the expression
results in <code>trap</code>.</p>
<p>Otherwise <code>r1</code> and <code>r2</code> are (respectively) a
location <code>v1</code> (a mutable identifier, an item of a mutable
array or a mutable field of an object) and a value <code>v2</code>. The
expression updates the current value stored in <code>v1</code> with the
new value <code>v2</code> and returns the empty tuple
<code>()</code>.</p>
<h3 id="unary-compound-assignment">Unary compound assignment</h3>
<p>The unary compound assignment <code>&lt;unop&gt;= &lt;exp&gt;</code>
has type <code>()</code> provided:</p>
<ul>
<li><p><code>&lt;exp&gt;</code> has type <code>var T</code>,
and</p></li>
<li><p><code>&lt;unop&gt;</code>'s category is a category of
<code>T</code>.</p></li>
</ul>
<p>The unary compound assignment <code>&lt;unop&gt;= &lt;exp&gt;</code>
evaluates <code>&lt;exp&gt;</code> to a result <code>r</code>. If
<code>r</code> is <code>trap</code> the evaluation traps, otherwise
<code>r</code> is a location storing value <code>v</code> and
<code>r</code> is updated to contain the value
<code>&lt;unop&gt; v</code>.</p>
<h3 id="binary-compound-assignment">Binary compound assignment</h3>
<p>The binary compound assignment
<code>&lt;exp1&gt; &lt;binop&gt;= &lt;exp2&gt;</code> has type
<code>()</code> provided:</p>
<ul>
<li><p><code>&lt;exp1&gt;</code> has type <code>var T</code>,
and</p></li>
<li><p><code>&lt;exp2&gt;</code> has type <code>T</code>, and</p></li>
<li><p><code>&lt;binop&gt;</code>'s category is a category of
<code>T</code>.</p></li>
</ul>
<p>For binary operator <code>&lt;binop&gt;</code>, the compound
assignment expression
<code>&lt;exp1&gt; &lt;binop&gt;= &lt;exp2&gt;</code> evaluates
<code>&lt;exp1&gt;</code> to a result <code>r1</code>. If
<code>r1</code> is <code>trap</code>, the expression results in
<code>trap</code>. Otherwise, <code>exp2</code> is evaluated to a result
<code>r2</code>. If <code>r2</code> is <code>trap</code>, the expression
results in <code>trap</code>.</p>
<p>Otherwise <code>r1</code> and <code>r2</code> are (respectively) a
location <code>v1</code> (a mutable identifier, an item of a mutable
array or a mutable field of object) and a value <code>v2</code>. The
expression updates the current value, <code>w</code> stored in
<code>v1</code> with the new value <code>w &lt;binop&gt; v2</code> and
returns the empty tuple <code>()</code>.</p>
<h3 id="arrays">Arrays</h3>
<p>The expression <code>[ var? &lt;exp&gt;,* ]</code> has type
<code>[var? T]</code> provided each expression <code>&lt;exp&gt;</code>
in the sequence <code>&lt;exp&gt;,*</code> has type T.</p>
<p>The array expression
<code>[ var &lt;exp0&gt;, …​, &lt;expn&gt; ]</code> evaluates the
expressions <code>exp0</code> …​ <code>expn</code> in order, trapping as
soon as some expression <code>&lt;expi&gt;</code> traps. If no
evaluation traps and <code>exp0</code>, …​, <code>&lt;expn&gt;</code>
evaluate to values <code>v0</code>,…​,<code>vn</code> then the array
expression returns the array value <code>[var? v0, …​ , vn]</code> (of
size <code>n+1</code>).</p>
<h3 id="array-indexing">Array indexing</h3>
<p>The array indexing expression
<code>&lt;exp1&gt; [ &lt;exp2&gt; ]</code> has type <code>var? T</code>
provided:</p>
<ul>
<li><code>&lt;exp&gt;</code> has (mutable or immutable) array type
<code>[var? T1]</code>.</li>
</ul>
<p>The expression <code>&lt;exp1&gt; [ &lt;exp2&gt; ]</code> evaluates
<code>exp1</code> to a result <code>r1</code>. If <code>r1</code> is
<code>trap</code>, then the result is <code>trap</code>.</p>
<p>Otherwise, <code>exp2</code> is evaluated to a result
<code>r2</code>. If <code>r2</code> is <code>trap</code>, the expression
results in <code>trap</code>.</p>
<p>Otherwise, <code>r1</code> is an array value,
<code>var? [v0, …​, vn]</code>, and <code>r2</code> is a natural integer
<code>i</code>. If <code>i &gt; n</code> the index expression returns
<code>trap</code>.</p>
<p>Otherwise, the index expression returns the value <code>v</code>,
obtained as follows:</p>
<p>If <code>var</code> is absent from <code>var? T</code> then the value
<code>v</code> is the constant value <code>vi</code>.</p>
<p>Otherwise,</p>
<ul>
<li><p>if the indexing occurs as the target of an assignment expression
then <code>v</code> is the <code>i</code>-th mutable location in the
array;</p></li>
<li><p>otherwise, <code>v</code> is <code>vi</code>, the value currently
stored in the <code>i</code>-th location of the array.</p></li>
</ul>
<h3 id="function-calls">Function calls</h3>
<p>The function call expression
<code>&lt;exp1&gt; &lt;T0,…​,Tn&gt;? &lt;exp2&gt;</code> has type
<code>T</code> provided:</p>
<ul>
<li><p>the function <code>&lt;exp1&gt;</code> has function type
<code>&lt;shared&gt;? &lt; X0 &lt;: V0, ..., Xn &lt;: Vn &gt; U1-&gt; U2</code>;
and</p></li>
<li><p>if <code>&lt;T0,…​,Tn&gt;?</code> is absent but n &gt; 0 then
there exists minimal <code>T0, …​, Tn</code> (inferred by the compiler)
such that:</p></li>
<li><p>each type argument satisfies the corresponding type parameter’s
bounds: for each <code>1 &lt;= i &lt;= n</code>,
<code>Ti &lt;: [T0/X0, …​, Tn/Xn]Vi</code>; and</p></li>
<li><p>the argument <code>&lt;exp2&gt;</code> has type
<code>[T0/X0, …​, Tn/Xn]U1</code>, and</p></li>
<li><p><code>T == [T0/X0, …​, Tn/Xn]U2</code>.</p></li>
</ul>
<p>The call expression
<code>&lt;exp1&gt; &lt;T0,…​,Tn&gt;? &lt;exp2&gt;</code> evaluates
<code>exp1</code> to a result <code>r1</code>. If <code>r1</code> is
<code>trap</code>, then the result is <code>trap</code>.</p>
<p>Otherwise, <code>exp2</code> is evaluated to a result
<code>r2</code>. If <code>r2</code> is <code>trap</code>, the expression
results in <code>trap</code>.</p>
<p>Otherwise, <code>r1</code> is a function value,
<code>&lt;shared-pat&gt;? func &lt;X0 &lt;: V0, …​, n &lt;: Vn&gt; &lt;pat1&gt; { &lt;exp&gt; }</code>
(for some implicit environment), and <code>r2</code> is a value
<code>v2</code>. If <code>&lt;shared-pat&gt;</code> is present and of
the form <code>shared &lt;query&gt;? &lt;pat&gt;</code> then evaluation
continues by matching the record value <code>{caller = p}</code> against
<code>&lt;pat&gt;</code>, where <code>p</code> is the
<code>Principal</code> invoking the function (typically a user or
canister). Matching continues by matching <code>v1</code> against
<code>&lt;pat1&gt;</code>. If pattern matching succeeds with some
bindings, then evaluation returns the result of <code>&lt;exp&gt;</code>
in the environment of the function value (not shown) extended with those
bindings. Otherwise, some pattern match has failed and the call results
in <code>trap</code>.</p>
<p>:::note</p>
<p>The exhaustiveness side condition on <code>shared</code> function
expressions ensures that argument pattern matching cannot fail (see <a
href="#functions">Functions</a>).</p>
<p>:::</p>
<p>:::note</p>
<p>Calls to local functions with <code>async</code> return type and
<code>shared</code> functions can fail due to a lack of canister
resources. Such failures will result in the call immediately throwing an
error with <code>code</code> <code>#call_error { err_code = n }</code>,
where <code>n</code> is the non-zero <code>err_code</code> value
returned by the Internet Computer. Earlier versions of Motoko would trap
in such situations, making it difficult for the calling canister to
mitigate such failures. Now, a caller can handle these errors using
enclosing <code>try ... catch ...</code> expressions, if desired.</p>
<p>:::</p>
<h3 id="functions">Functions</h3>
<p>The function expression
<code>&lt;shared-pat&gt;? func &lt; X0 &lt;: T0, …​, Xn &lt;: Tn &gt; &lt;pat1&gt; (: U2)? =? &lt;block-or-exp&gt;</code>
has type
<code>&lt;shared&gt;? &lt; X0 &lt;: T0, ..., Xn &lt;: Tn &gt; U1-&gt; U2</code>
if, under the assumption that
<code>X0 &lt;: T0, …​, Xn &lt;: Tn</code>:</p>
<ul>
<li><p><code>&lt;shared-pat&gt;?</code> is of the form
<code>shared &lt;query&gt;? &lt;pat&gt;</code> if and only if
<code>&lt;shared&gt;?</code> is <code>shared &lt;query&gt;?</code> (the
<code>&lt;query&gt;</code> modifiers must agree, i.e. are either both
absent, both <code>query</code>, or both
<code>composite query</code>);</p></li>
<li><p>all the types in <code>T0, …​, Tn</code> and <code>U2</code> are
well-formed and well-constrained;</p></li>
<li><p>pattern <code>&lt;pat&gt;</code> has <em>context type</em>
<code>{ caller : Principal }</code>;</p></li>
<li><p>pattern <code>&lt;pat1&gt;</code> has type
<code>U1</code>;</p></li>
<li><p>if the function is <code>shared</code> then
<code>&lt;pat&gt;</code> and <code>&lt;pat1&gt;</code> must be
exhaustive;</p></li>
<li><p>expression <code>&lt;block-or-exp&gt;</code> has type return type
<code>U2</code> under the assumption that <code>&lt;pat1&gt;</code> has
type <code>U1</code>.</p></li>
</ul>
<p><code>&lt;shared-pat&gt;? func &lt;typ-params&gt;? &lt;pat1&gt; (: &lt;typ&gt;)? =? &lt;block-or-exp&gt;</code>
evaluates to a function value (a.k.a. closure), denoted
<code>&lt;shared-pat&gt;? func &lt;typ-params&gt;? &lt;pat1&gt; = &lt;exp&gt;</code>,
that stores the code of the function together with the bindings from the
current evaluation environment (not shown) needed to evaluate calls to
the function value.</p>
<p>Note that a <code>&lt;shared-pat&gt;</code> function may itself be
<code>shared &lt;pat&gt;</code> or <code>shared query &lt;pat&gt;</code>
or <code>shared composite query &lt;pat&gt;</code>.</p>
<ul>
<li><p>A <code>shared &lt;pat&gt;</code> function may be invoked from a
remote caller. Unless causing a trap, the effects on the callee persist
beyond completion of the call.</p></li>
<li><p>A <code>shared query &lt;pat&gt;</code> function may be also be
invoked from a remote caller, but the effects on the callee are
transient and discarded once the call has completed with a result
(whether a value or error).</p></li>
<li><p>A <code>shared composite query &lt;pat&gt;</code> function may
only be invoked as an ingress message, not from a remote caller. Like a
query, the effects on the callee are transient and discarded once the
call has completed with a result (whether a value or error). In
addition, intermediate state changes made by the call are not observable
by any of its own <code>query</code> or <code>composite query</code>
callees.</p></li>
</ul>
<p>In either case, <code>&lt;pat&gt;</code> provides access to a context
value identifying the <em>caller</em> of the shared (query)
function.</p>
<p>:::note</p>
<p>The context type is a record to allow extension with further fields
in future releases.</p>
<p>:::</p>
<p>Shared functions have different capabilities dependent on their
qualification as <code>shared</code>, <code>shared query</code> or
<code>shared composite query</code>.</p>
<p>A <code>shared</code> function may call any <code>shared</code> or
<code>shared query</code> function, but no
<code>shared composite query</code> function. A
<code>shared query</code> function may not call any <code>shared</code>,
<code>shared query</code> or <code>shared composite query</code>
function. A <code>shared composite query</code> function may call any
<code>shared query</code> or <code>shared composite query</code>
function, but no <code>shared</code> function.</p>
<p>All varieties of shared functions may call unshared functions.</p>
<p>Composite queries, though composable, can only be called externally
(from a frontend) and cannot be initiated from an actor.</p>
<h3 id="blocks">Blocks</h3>
<p>The block expression <code>{ &lt;dec&gt;;* }</code> has type
<code>T</code> provided the last declaration in the sequence
<code>&lt;dec&gt;;*</code> has type <code>T</code>. All identifiers
declared in block must be distinct type identifiers or distinct value
identifiers and are in scope in the definition of all other declarations
in the block.</p>
<p>The bindings of identifiers declared in <code>{ dec;* }</code> are
local to the block.</p>
<p>The type system ensures that a value identifier cannot be evaluated
before its declaration has been evaluated, precluding run-time errors at
the cost of rejection some well-behaved programs.</p>
<p>Identifiers whose types cannot be inferred from their declaration,
but are used in a forward reference, may require an additional type
annotation (see <a href="#annotated-pattern">Annotated pattern</a>) to
satisfy the type checker.</p>
<p>The block expression <code>{ &lt;dec&gt;;* }</code> evaluates each
declaration in <code>&lt;dec&gt;;*</code> in sequence (program order).
The first declaration in <code>&lt;dec&gt;;*</code> that results in a
trap causes the block to result in <code>trap</code>, without evaluating
subsequent declarations.</p>
<h3 id="do">Do</h3>
<p>The do expression <code>do &lt;block&gt;</code> allows the use of a
block as an expression, in positions where the syntax would not directly
allow a block.</p>
<p>The expression <code>do &lt;block&gt;</code> has type <code>T</code>
provided <code>&lt;block&gt;</code> has type <code>T</code>.</p>
<p>The <code>do</code> expression evaluates by evaluating
<code>&lt;block&gt;</code> and returning its result.</p>
<h3 id="option-block">Option block</h3>
<p>The option block <code>do ? &lt;block&gt;</code> introduces scoped
handling of null values.</p>
<p>The expression <code>do ? &lt;block&gt;</code> has type
<code>?T</code> provided <code>&lt;block&gt;</code> has type
<code>T</code>.</p>
<p>The <code>do ? &lt;block&gt;</code> expression evaluates
<code>&lt;block&gt;</code> and returns its result as an optional
value.</p>
<p>Within <code>&lt;block&gt;</code> the null break expression
<code>&lt;exp1&gt; !</code> exits the nearest enclosing
<code>do ?</code> block with value <code>null</code> whenever
<code>&lt;exp1&gt;</code> has value <code>null</code>, or continues
evaluation with the contents of <code>&lt;exp1&gt;</code>'s option
value. (See <a href="#null-break">Null break</a>.)</p>
<p>Option blocks nest with the target of a null break determined by the
nearest enclosing option block.</p>
<h3 id="null-break">Null break</h3>
<p>The null break expression <code>&lt;exp&gt; !</code> invokes scoped
handling of null values and returns the contents of an option value or
changes control-flow when the value is <code>null</code>.</p>
<p>It has type <code>T</code> provided:</p>
<ul>
<li><p>the expression appears in the body, <code>&lt;block&gt;</code>,
of an enclosing option block of the form <code>do ? &lt;block&gt;</code>
(see <a href="#do-opt">Option block</a>).</p></li>
<li><p><code>&lt;exp&gt;</code> has option type
<code>? T</code>.</p></li>
</ul>
<p>The expression <code>&lt;exp&gt; !</code> evaluates
<code>&lt;exp&gt;</code> to a result <code>r</code>. If <code>r</code>
is <code>trap</code>, then the result is <code>trap</code>; if
<code>r</code> is <code>null</code>, execution breaks with value
<code>null</code> from the nearest enclosing option block of form
<code>do ? &lt;block&gt;</code>; otherwise, <code>r</code> is
<code>? v</code> and execution continues with value <code>v</code>.</p>
<h3 id="not">Not</h3>
<p>The not expression <code>not &lt;exp&gt;</code> has type
<code>Bool</code> provided <code>&lt;exp&gt;</code> has type
<code>Bool</code>.</p>
<p>If <code>&lt;exp&gt;</code> evaluates to <code>trap</code>, the
expression returns <code>trap</code>. Otherwise,
<code>&lt;exp&gt;</code> evaluates to a Boolean value <code>v</code> and
the expression returns <code>not v</code>, (the Boolean negation of
<code>v</code>).</p>
<h3 id="and">And</h3>
<p>The and expression <code>&lt;exp1&gt; and &lt;exp2&gt;</code> has
type <code>Bool</code> provided <code>&lt;exp1&gt;</code> and
<code>&lt;exp2&gt;</code> have type <code>Bool</code>.</p>
<p>The expression <code>&lt;exp1&gt; and &lt;exp2&gt;</code> evaluates
<code>exp1</code> to a result <code>r1</code>. If <code>r1</code> is
<code>trap</code>, the expression results in <code>trap</code>.
Otherwise <code>r1</code> is a Boolean value <code>v</code>. If
<code>v == false</code> the expression returns the value
<code>false</code> (without evaluating <code>&lt;exp2&gt;</code>).
Otherwise, the expression returns the result of evaluating
<code>&lt;exp2&gt;</code>.</p>
<h3 id="or">Or</h3>
<p>The or expression <code>&lt;exp1&gt; or &lt;exp2&gt;</code> has type
<code>Bool</code> provided <code>&lt;exp1&gt;</code> and
<code>&lt;exp2&gt;</code> have type <code>Bool</code>.</p>
<p>The expression <code>&lt;exp1&gt; and &lt;exp2&gt;</code> evaluates
<code>exp1</code> to a result <code>r1</code>. If <code>r1</code> is
<code>trap</code>, the expression results in <code>trap</code>.
Otherwise <code>r1</code> is a Boolean value <code>v</code>. If
<code>v == true</code> the expression returns the value
<code>true</code> (without evaluating <code>&lt;exp2&gt;</code>).
Otherwise, the expression returns the result of evaluating
<code>&lt;exp2&gt;</code>.</p>
<h3 id="if">If</h3>
<p>The expression
<code>if &lt;exp1&gt; &lt;exp2&gt; (else &lt;exp3&gt;)?</code> has type
<code>T</code> provided:</p>
<ul>
<li><p><code>&lt;exp1&gt;</code> has type <code>Bool</code></p></li>
<li><p><code>&lt;exp2&gt;</code> has type <code>T</code></p></li>
<li><p><code>&lt;exp3&gt;</code> is absent and <code>() &lt;: T</code>,
or</p></li>
<li><p><code>&lt;exp3&gt;</code> is present and has type
<code>T</code>.</p></li>
</ul>
<p>The expression evaluates <code>&lt;exp1&gt;</code> to a result
<code>r1</code>. If <code>r1</code> is <code>trap</code>, the result is
<code>trap</code>. Otherwise, <code>r1</code> is the value
<code>true</code> or <code>false</code>. If <code>r1</code> is
<code>true</code>, the result is the result of evaluating
<code>&lt;exp2&gt;</code>. Otherwise, <code>r1</code> is
<code>false</code> and the result is <code>()</code> (if
<code>&lt;exp3&gt;</code> is absent) or the result of
<code>&lt;exp3&gt;</code> (if <code>&lt;exp3&gt;</code> is present).</p>
<h3 id="switch">Switch</h3>
<p>The switch expression
<code>switch &lt;exp&gt; { (case &lt;pat&gt; &lt;block-or-exp&gt;;)+ }</code>
has type <code>T</code> provided:</p>
<ul>
<li><p><code>exp</code> has type <code>U</code>; and</p></li>
<li><p>for each case <code>case &lt;pat&gt; &lt;block-or-exp&gt;</code>
in the sequence <code>(case &lt;pat&gt; &lt;block-or-exp&gt;;)+</code>
:</p></li>
<li><p>pattern <code>&lt;pat&gt;</code> has type <code>U</code>;
and,</p></li>
<li><p>expression <code>&lt;block-or-exp&gt;</code> has type
<code>T</code></p></li>
</ul>
<p>The expression evaluates <code>&lt;exp&gt;</code> to a result
<code>r</code>. If <code>r</code> is <code>trap</code>, the result is
<code>trap</code>. Otherwise, <code>r</code> is some value
<code>v</code>. Let <code>case &lt;pat&gt; &lt;block-or-exp&gt;;</code>
be the first case in
<code>(case &lt;pat&gt; &lt;block-or-exp&gt;;)+</code> such that
<code>&lt;pat&gt;</code> matches <code>v</code> for some binding of
identifiers to values. Then result of the <code>switch</code> is the
result of evaluating <code>&lt;block-or-exp&gt;</code> under that
binding. If no case has a pattern that matches <code>v</code>, the
result of the switch is <code>trap</code>.</p>
<h3 id="while">While</h3>
<p>The expression <code>while &lt;exp1&gt; &lt;exp2&gt;</code> has type
<code>()</code> provided:</p>
<ul>
<li><p><code>&lt;exp1&gt;</code> has type <code>Bool</code>,
and</p></li>
<li><p><code>&lt;exp2&gt;</code> has type <code>()</code>.</p></li>
</ul>
<p>The expression evaluates <code>&lt;exp1&gt;</code> to a result
<code>r1</code>. If <code>r1</code> is <code>trap</code>, the result is
<code>trap</code>. Otherwise, <code>r1</code> is the value
<code>true</code> or <code>false</code>. If <code>r1</code> is
<code>true</code>, the result is the result of re-evaluating
<code>while &lt;exp1&gt; &lt;exp2&gt;</code>. Otherwise, the result is
<code>()</code>.</p>
<h3 id="loop">Loop</h3>
<p>The expression <code>loop &lt;block-or-exp&gt;</code> has type
<code>None</code> provided <code>&lt;block-or-exp&gt;</code> has type
<code>()</code>.</p>
<p>The expression evaluates <code>&lt;block-or-exp&gt;</code> to a
result <code>r1</code>. If <code>r1</code> is <code>trap</code>, the
result is <code>trap</code>. Otherwise, the result is the result of
(re-)evaluating <code>loop &lt;block-or-exp&gt;</code>.</p>
<h3 id="loop-while">Loop-while</h3>
<p>The expression
<code>loop &lt;block-or-exp1&gt; while &lt;exp2&gt;</code> has type
<code>()</code> provided:</p>
<ul>
<li><p><code>&lt;block-or-exp1&gt;</code> has type <code>()</code>,
and</p></li>
<li><p><code>&lt;exp2&gt;</code> has type <code>Bool</code>.</p></li>
</ul>
<p>The expression evaluates <code>&lt;block-or-exp1&gt;</code> to a
result <code>r1</code>. If <code>r1</code> is <code>trap</code>, the
result is <code>trap</code>. Otherwise, evaluation continues with
<code>&lt;exp2&gt;</code>, producing result <code>r2</code>. If
<code>r2</code> is <code>trap</code> the result is <code>trap</code>.
Otherwise, if <code>r2</code> is <code>true</code>, the result is the
result of re-evaluating
<code>loop &lt;block-or-exp1&gt; while &lt;exp2&gt;</code>. Otherwise,
<code>r2</code> is false and the result is <code>()</code>.</p>
<h3 id="for">For</h3>
<p>The iterator expression
<code>for ( &lt;pat&gt; in &lt;exp1&gt; ) &lt;block-or-exp2&gt;</code>
has type <code>()</code> provided:</p>
<ul>
<li><p><code>&lt;exp1&gt;</code> has type
<code>{ next : () → ?T }</code>,</p></li>
<li><p>pattern <code>&lt;pat&gt;</code> has type <code>T</code>,
and</p></li>
<li><p>expression <code>&lt;block-or-exp2&gt;</code> has type
<code>()</code> (in the environment extended with the bindings of
<code>&lt;pat&gt;</code>).</p></li>
</ul>
<p>The <code>for</code>-expression is syntactic sugar for</p>
<pre class="bnf"><code>for ( &lt;pat&gt; in &lt;exp1&gt; ) &lt;block-or-exp2&gt; :=
  {
    let x = &lt;exp1&gt;;
    label l loop {
      switch (x.next()) {
        case (? &lt;pat&gt;) &lt;block-or-exp2&gt;;
        case (null) break l;
      }
    }
  }</code></pre>
<p>where <code>x</code> and <code>l</code> are fresh identifiers.</p>
<p>In particular, the <code>for</code> loop will trap if evaluation of
<code>&lt;exp1&gt;</code> traps; as soon as <code>x.next()</code> traps,
or the value of <code>x.next()</code> does not match pattern
<code>&lt;pat&gt;</code>, or when <code>&lt;block-or-exp2&gt;</code>
traps.</p>
<p>:::note</p>
<p>Although general purpose, <code>for</code> loops are commonly used to
consume iterators produced by <a href="#special-member-access">Special
member access</a> to, for example, loop over the indices
(<code>a.keys()</code>) or values (<code>a.vals()</code>) of some array
(here <code>a</code>).</p>
<p>:::</p>
<h3 id="label">Label</h3>
<p>The label-expression
<code>label &lt;id&gt; (: &lt;typ&gt;)? &lt;block-or-exp&gt;</code> has
type <code>T</code> provided:</p>
<ul>
<li><p><code>(: &lt;typ&gt;)?</code> is absent and <code>T</code> is
unit; or <code>(: &lt;typ&gt;)?</code> is present and
<code>T == &lt;typ&gt;</code>;</p></li>
<li><p><code>&lt;block-or-exp&gt;</code> has type <code>T</code> in the
static environment extended with <code>label l : T</code>.</p></li>
</ul>
<p>The result of evaluating
<code>label &lt;id&gt; (: &lt;typ&gt;)? &lt;block-or-exp&gt;</code> is
the result of evaluating <code>&lt;block-or-exp&gt;</code>.</p>
<h3 id="labeled-loops">Labeled loops</h3>
<p>If <code>&lt;exp&gt;</code> in
<code>label &lt;id&gt; (: &lt;typ&gt;)? &lt;exp&gt;</code> is a looping
construct:</p>
<ul>
<li><p><code>while (exp2) &lt;block-or-exp1&gt;</code>,</p></li>
<li><p><code>loop &lt;block-or-exp1&gt; (while (&lt;exp2&gt;))?</code>,
or</p></li>
<li><p><code>for (&lt;pat&gt; in &lt;exp2&gt;) &lt;block-or-exp1&gt;</code></p></li>
</ul>
<p>the body, <code>&lt;exp1&gt;</code>, of the loop is implicitly
enclosed in <code>label &lt;id_continue&gt; (…​)</code> allowing early
continuation of the loop by the evaluation of expression
<code>continue &lt;id&gt;</code>.</p>
<p><code>&lt;id_continue&gt;</code> is fresh identifier that can only be
referenced by <code>continue &lt;id&gt;</code> (through its implicit
expansion to <code>break &lt;id_continue&gt;</code>).</p>
<h3 id="break">Break</h3>
<p>The expression <code>break &lt;id&gt;</code> is equivalent to
<code>break &lt;id&gt; ()</code>.</p>
<p>The expression <code>break &lt;id&gt; &lt;exp&gt;</code> has type
<code>None</code> provided:</p>
<ul>
<li><p>The label <code>&lt;id&gt;</code> is declared with type
<code>label &lt;id&gt; : T</code>.</p></li>
<li><p><code>&lt;exp&gt;</code> has type <code>T</code>.</p></li>
</ul>
<p>The evaluation of <code>break &lt;id&gt; &lt;exp&gt;</code> evaluates
exp to some result <code>r</code>. If <code>r</code> is
<code>trap</code>, the result is <code>trap</code>. If <code>r</code> is
a value <code>v</code>, the evaluation abandons the current computation
up to dynamically enclosing declaration <code>label &lt;id&gt; …​</code>
using the value <code>v</code> as the result of that labelled
expression.</p>
<h3 id="continue">Continue</h3>
<p>The expression <code>continue &lt;id&gt;</code> is equivalent to
<code>break &lt;id_continue&gt;</code>, where
<code>&lt;id_continue&gt;</code> is implicitly declared around the
bodies of <code>&lt;id&gt;</code>-labelled looping constructs (see <a
href="#labeled-loops">Labeled loops</a>).</p>
<h3 id="return">Return</h3>
<p>The expression <code>return</code> is equivalent to
<code>return ()</code>.</p>
<p>The expression <code>return &lt;exp&gt;</code> has type
<code>None</code> provided:</p>
<ul>
<li><p><code>&lt;exp&gt;</code> has type <code>T</code> and</p></li>
<li><p><code>T</code> is the return type of the nearest enclosing
function (with no intervening <code>async</code> expression),
or</p></li>
<li><p><code>async T</code> is the type of the nearest enclosing
(perhaps implicit) <code>async</code> expression (with no intervening
function declaration)</p></li>
</ul>
<p>The <code>return</code> expression exits the corresponding dynamic
function invocation or completes the corresponding dynamic
<code>async</code> or <code>async*</code> expression with the result of
<code>&lt;exp&gt;</code>.</p>
<h3 id="async">Async</h3>
<p>The async expression <code>async &lt;block-or-exp&gt;</code> has type
<code>async T</code> provided:</p>
<ul>
<li><p><code>&lt;block-or-exp&gt;</code> has type
<code>T</code>;</p></li>
<li><p><code>T</code> is shared.</p></li>
</ul>
<p>Any control-flow label in scope for
<code>async &lt;block-or-exp&gt;</code> is not in scope for
<code>&lt;block-or-exp&gt;</code>. However,
<code>&lt;block-or-exp&gt;</code> may declare and use its own, local,
labels.</p>
<p>The implicit return type in <code>&lt;block-or-exp&gt;</code> is
<code>T</code>. That is, the return expression,
<code>&lt;exp0&gt;</code>, (implicit or explicit) to any enclosed
<code>return &lt;exp0&gt;?</code> expression, must have type
<code>T</code>.</p>
<p>Evaluation of <code>async &lt;block-or-exp&gt;</code> queues a
message to evaluate <code>&lt;block-or-exp&gt;</code> in the nearest
enclosing or top-level actor. It immediately returns a future of type
<code>async T</code> that can be used to <code>await</code> the result
of the pending evaluation of <code>&lt;exp&gt;</code>.</p>
<p>:::note</p>
<p>Because it involves messaging, evaluating an <code>async</code>
expression can fail due to a lack of canister resources. Such failures
will result in the call immediately throwing an error with
<code>code</code> <code>#call_error { err_code = n }</code>, where
<code>n</code> is the non-zero <code>err_code</code> value returned by
the Internet Computer. Earlier version of Motoko would trap in such
situations, making it difficult for the producer of the async expression
to mitigate such failures. Now, the producer can handle these errors
using an enclosing <code>try ... catch ...</code> expression, if
desired.</p>
<p>:::</p>
<h3 id="await">Await</h3>
<p>The <code>await</code> expression <code>await &lt;exp&gt;</code> has
type <code>T</code> provided:</p>
<ul>
<li><p><code>&lt;exp&gt;</code> has type <code>async T</code>,</p></li>
<li><p><code>T</code> is shared,</p></li>
<li><p>the <code>await</code> is explicitly enclosed by an
<code>async</code>-expression or appears in the body of a
<code>shared</code> function.</p></li>
</ul>
<p>Expression <code>await &lt;exp&gt;</code> evaluates
<code>&lt;exp&gt;</code> to a result <code>r</code>. If <code>r</code>
is <code>trap</code>, evaluation returns <code>trap</code>. Otherwise
<code>r</code> is a future. If the <code>future</code> is incomplete,
that is, its evaluation is still pending, <code>await &lt;exp&gt;</code>
suspends evaluation of the neared enclosing <code>async</code> or
<code>shared</code>-function, adding the suspension to the wait-queue of
the <code>future</code>. Execution of the suspension is resumed once the
future is completed (if ever). If the future is complete with value
<code>v</code>, then <code>await &lt;exp&gt;</code> suspends evaluation
and schedules resumption of execution with value <code>v</code>. If the
future is complete with (thrown) error value <code>e</code>, then
<code>await &lt;exp&gt;</code> suspends evaluation and schedules
resumption of execution by re-throwing the error <code>e</code>.</p>
<p>Note: suspending computation on <code>await</code>, regardless of the
dynamic status of the future, ensures that all tentative state changes
and message sends prior to the <code>await</code> are committed and
irrevocable.</p>
<p>:::danger</p>
<p>Between suspension and resumption of a computation, the state of the
enclosing actor may change due to concurrent processing of other
incoming actor messages. It is the programmer’s responsibility to guard
against non-synchronized state changes.</p>
<p>Using <code>await</code> signals that the computation <em>will</em>
commit its current state and suspend execution.</p>
<p>:::</p>
<p>:::note</p>
<p>Because it involves additional messaging, an <code>await</code> on a
completed future can, in rare circumstances, fail due to a lack of
canister resources. Such failures will result in the call immediately
throwing an error with <code>code</code>
<code>#call_error { err_code = n }</code>, where <code>n</code> is the
non-zero <code>err_code</code> value returned by the Internet Computer
The error is produced eagerly, without suspending nor committing state.
Earlier versions of Motoko would trap in such situations, making it
difficult for the consumer of the <code>await</code> to mitigate such
failures. Now, the consumer can handle these errors by using an
enclosing <code>try ... catch ...</code> expression, if desired.</p>
<p>:::</p>
<h3 id="async-1">Async*</h3>
<p>The async expression <code>async* &lt;block-or-exp&gt;</code> has
type <code>async* T</code> provided:</p>
<ul>
<li><p><code>&lt;block-or-exp&gt;</code> has type
<code>T</code>;</p></li>
<li><p><code>T</code> is shared.</p></li>
</ul>
<p>Any control-flow label in scope for
<code>async* &lt;block-or-exp&gt;</code> is not in scope for
<code>&lt;block-or-exp&gt;</code>. However,
<code>&lt;block-or-exp&gt;</code> may declare and use its own, local,
labels.</p>
<p>The implicit return type in <code>&lt;block-or-exp&gt;</code> is
<code>T</code>. That is, the return expression,
<code>&lt;exp0&gt;</code>, (implicit or explicit) to any enclosed
<code>return &lt;exp0&gt;?</code> expression, must have type
<code>T</code>.</p>
<p>Evaluation of <code>async* &lt;block-or-exp&gt;</code> produces a
delayed computation to evaluate <code>&lt;block-or-exp&gt;</code>. It
immediately returns a value of type <code>async* T</code>. The delayed
computation can be executed using <code>await*</code>, producing one
evaluation of the computation <code>&lt;block-or-exp&gt;</code>.</p>
<p>:::danger</p>
<p>Note that <code>async &lt;block-or-exp&gt;</code> has the effect of
scheduling a single asynchronous computation of
<code>&lt;exp&gt;</code>, regardless of whether its result, a future, is
consumed with an <code>await</code>. Moreover, each additional
consumption by an <code>await</code> just returns the previous result,
without repeating the computation.</p>
<p>In comparison, <code>async* &lt;block-or_exp&gt;</code>, has <em>no
effect</em> until its value is consumed by an <code>await*</code>.
Moreover, each additional consumption by an <code>await*</code> will
trigger a new evaluation of <code>&lt;block-or-exp&gt;</code>, including
repeated effects.</p>
<p>Be careful of this distinction, and other differences, when
refactoring code.</p>
<p>:::</p>
<p>:::note</p>
<p>The <code>async*</code> and corresponding <code>await*</code>
constructs are useful for efficiently abstracting asynchronous code into
re-useable functions. In comparison, calling a local function that
returns a proper <code>async</code> type requires committing state and
suspending execution with each <code>await</code> of its result, which
can be undesirable.</p>
<p>:::</p>
<h3 id="await-1">Await*</h3>
<p>The <code>await*</code> expression <code>await* &lt;exp&gt;</code>
has type <code>T</code> provided:</p>
<ul>
<li><p><code>&lt;exp&gt;</code> has type <code>async* T</code>,</p></li>
<li><p><code>T</code> is shared,</p></li>
<li><p>the <code>await*</code> is explicitly enclosed by an
<code>async</code>-expression or appears in the body of a
<code>shared</code> function.</p></li>
</ul>
<p>Expression <code>await* &lt;exp&gt;</code> evaluates
<code>&lt;exp&gt;</code> to a result <code>r</code>. If <code>r</code>
is <code>trap</code>, evaluation returns <code>trap</code>. Otherwise
<code>r</code> is a delayed computation
<code>&lt;block-or-exp&gt;</code>. The evaluation of
<code>await* &lt;exp&gt;</code> proceeds with the evaluation of
<code>&lt;block-or-exp&gt;</code>, executing the delayed
computation.</p>
<p>:::danger</p>
<p>During the evaluation of <code>&lt;block-or-exp&gt;</code>, the state
of the enclosing actor may change due to concurrent processing of other
incoming actor messages. It is the programmer’s responsibility to guard
against non-synchronized state changes.</p>
<p>:::</p>
<p>:::note</p>
<p>Unlike <code>await</code>, which, regardless of the dynamic status of
the future, ensures that all tentative state changes and message sends
prior to the <code>await</code> are committed and irrevocable,
<code>await*</code> does not, in itself, commit any state changes, nor
does it suspend computation. Instead, evaluation proceeds immediately
according to <code>&lt;block-or-exp&gt;</code> (the value of
<code>&lt;exp&gt;</code>), committing state and suspending execution
whenever <code>&lt;block-or-exp&gt;</code> does (but not otherwise).</p>
<p>:::</p>
<p>:::note</p>
<p>Evaluation of a delayed <code>async*</code> block is synchronous
while possible, switching to asynchronous when necessary due to a proper
<code>await</code>.</p>
<p>Using <code>await*</code> signals that the computation <em>may</em>
commit state and suspend execution during the evaluation of
<code>&lt;block-or-exp&gt;</code>, that is, that evaluation of
<code>&lt;block-or-exp&gt;</code> may perform zero or more proper
<code>await</code>s and may be interleaved with the execution of other,
concurrent messages.</p>
<p>:::</p>
<h3 id="throw">Throw</h3>
<p>The <code>throw</code> expression <code>throw &lt;exp&gt;</code> has
type <code>None</code> provided:</p>
<ul>
<li><p><code>&lt;exp&gt;</code> has type <code>Error</code>,</p></li>
<li><p>the <code>throw</code> is explicitly enclosed by an
<code>async</code>-expression or appears in the body of a
<code>shared</code> function.</p></li>
</ul>
<p>Expression <code>throw &lt;exp&gt;</code> evaluates
<code>&lt;exp&gt;</code> to a result <code>r</code>. If <code>r</code>
is <code>trap</code>, evaluation returns <code>trap</code>. Otherwise
<code>r</code> is an error value <code>e</code>. Execution proceeds from
the <code>catch</code> clause of the nearest enclosing
<code>try &lt;block-or-exp1&gt; catch &lt;pat&gt; &lt;block-or-exp2&gt;</code>
whose pattern <code>&lt;pat&gt;</code> matches value <code>e</code>. If
there is no such <code>try</code> expression, <code>e</code> is stored
as the erroneous result of the <code>async</code> value of the nearest
enclosing <code>async</code>, <code>async*</code> expression or
<code>shared</code> function invocation.</p>
<h3 id="try">Try</h3>
<p>The <code>try</code> expression
<code>try &lt;block-or-exp1&gt; catch &lt;pat&gt; &lt;block-or-exp2&gt;</code>
has type <code>T</code> provided:</p>
<ul>
<li><p><code>&lt;block-or-exp1&gt;</code> has type
<code>T</code>,</p></li>
<li><p><code>&lt;pat&gt;</code> has type <code>Error</code> and
<code>&lt;block-or-exp2&gt;</code> has type <code>T</code> in the
context extended with <code>&lt;pat&gt;</code>, and</p></li>
<li><p>the <code>try</code> is explicitly enclosed by an
<code>async</code>-expression or appears in the body of a
<code>shared</code> function.</p></li>
</ul>
<p>Expression
<code>try &lt;block-or-exp1&gt; catch &lt;pat&gt; &lt;block-or-exp2&gt;</code>
evaluates <code>&lt;block-or-exp1&gt;</code> to a result <code>r</code>.
If evaluation of <code>&lt;block-or-exp1&gt;</code> throws an uncaught
error value <code>e</code>, the result of the <code>try</code> is the
result of evaluating <code>&lt;block-or-exp2&gt;</code> under the
bindings determined by the match of <code>e</code> against
<code>pat</code>.</p>
<p>:::note</p>
<p>Because the <code>Error</code> type is opaque, the pattern match
cannot fail (typing ensures that <code>&lt;pat&gt;</code> is an
irrefutable wildcard or identifier pattern).</p>
<p>:::</p>
<p>See <a href="#error-type">Error type</a>.</p>
<h3 id="assert">Assert</h3>
<p>The assert expression <code>assert &lt;exp&gt;</code> has type
<code>()</code> provided <code>&lt;exp&gt;</code> has type
<code>Bool</code>.</p>
<p>Expression <code>assert &lt;exp&gt;</code> evaluates
<code>&lt;exp&gt;</code> to a result <code>r</code>. If <code>r</code>
is <code>trap</code> evaluation returns <code>trap</code>. Otherwise
<code>r</code> is a Boolean value <code>v</code>. The result of
<code>assert &lt;exp&gt;</code> is:</p>
<ul>
<li><p>the value <code>()</code>, when <code>v</code> is
<code>true</code>; or</p></li>
<li><p><code>trap</code>, when <code>v</code> is
<code>false</code>.</p></li>
</ul>
<h3 id="type-annotation">Type annotation</h3>
<p>The type annotation expression <code>&lt;exp&gt; : &lt;typ&gt;</code>
has type <code>T</code> provided:</p>
<ul>
<li><p><code>&lt;typ&gt;</code> is <code>T</code>, and</p></li>
<li><p><code>&lt;exp&gt;</code> has type <code>U</code> where
<code>U &lt;: T</code>.</p></li>
</ul>
<p>Type annotation may be used to aid the type-checker when it cannot
otherwise determine the type of <code>&lt;exp&gt;</code> or when one
wants to constrain the inferred type, <code>U</code> of
<code>&lt;exp&gt;</code> to a less-informative super-type <code>T</code>
provided <code>U &lt;: T</code>.</p>
<p>The result of evaluating <code>&lt;exp&gt; : &lt;typ&gt;</code> is
the result of evaluating <code>&lt;exp&gt;</code>.</p>
<p>:::note</p>
<p>Type annotations have no-runtime cost and cannot be used to perform
the (checked or unchecked) <code>down-casts</code> available in other
object-oriented languages.</p>
<p>:::</p>
<h3 id="candid-serialization">Candid Serialization</h3>
<p>The <em>Candid serialization</em> expression
<code>to_candid ( &lt;exp&gt;,*)</code> has type <code>Blob</code>
provided:</p>
<ul>
<li><code>(&lt;exp&gt;,*)</code> has type <code>(T1,…​,Tn)</code>, and
each <code>Ti</code> is <em>shared</em>.</li>
</ul>
<p>Expression <code>to_candid ( &lt;exp&gt;,* )</code> evaluates the
expression sequence <code>( &lt;exp&gt;,* )</code> to a result
<code>r</code>. If <code>r</code> is <code>trap</code>, evaluation
returns <code>trap</code>. Otherwise, <code>r</code> is a sequence of
Motoko values <code>vs</code>. The result of evaluating
<code>to_candid ( &lt;exp&gt;,* )</code> is some Candid blob
<code>b = encode((T1,...,Tn))(vs)</code>, encoding <code>vs</code>.</p>
<p>The Candid <em>deserialization</em> expression
<code>from_candid &lt;exp&gt;</code> has type <code>?(T1,…​,Tn)</code>
provided:</p>
<ul>
<li><p><code>?(T1,…​,Tn)</code> is the expected type from the
context;</p></li>
<li><p><code>&lt;exp&gt;</code> has type <code>Blob</code>; and</p></li>
<li><p><code>?(T1,…​,Tn)</code> is <em>shared</em>.</p></li>
</ul>
<p>Expression <code>from_candid &lt;exp&gt;</code> evaluates
<code>&lt;exp&gt;</code> to a result <code>r</code>. If <code>r</code>
is <code>trap</code>, evaluation returns <code>trap</code>. Otherwise
<code>r</code> is a binary blob <code>b</code>. If <code>b</code>
Candid-decodes to Candid value sequence <code>Vs</code> of type
<code>ea((T1,...,Tn))</code> then the result of <code>from_candid</code>
is <code>?v</code> where <code>v = decode((T1,...,Tn))(Vs)</code>. If
<code>b</code> Candid-decodes to a Candid value sequence <code>Vs</code>
that is not of Candid type <code>ea((T1,...,Tn))</code> (but well-formed
at some other type) then the result is <code>null</code>. If
<code>b</code> is not the encoding of any well-typed Candid value, but
some arbitrary binary blob, then the result of <code>from_candid</code>
is a trap.</p>
<p>(Informally, here <code>ea(_)</code> is the Motoko-to-Candid type
sequence translation and <code>encode/decode((T1,...,Tn))(_)</code> are
type-directed Motoko-Candid value translations.)</p>
<!--
ea(_) is defined in design doc motoko/design/IDL-Motoko.md, but `encode` and `decode` are not explicitly defined anywhere except in the implementation.
-->

<p>:::note</p>
<p>Operation <code>from_candid</code> returns <code>null</code> when the
argument is a valid Candid encoding of the wrong type. It traps if the
blob is not a valid Candid encoding at all.</p>
<p>:::</p>
<p>:::note</p>
<p>Operations <code>to_candid</code> and <code>from_candid</code> are
syntactic operators, not first-class functions, and must be fully
applied in the syntax.</p>
<p>:::</p>
<p>:::danger</p>
<p>The Candid encoding of a value as a blob is not unique and the same
value may have many different Candid representations as a blob. For this
reason, blobs should never be used to, for instance, compute hashes of
values or determine equality, whether across compiler versions or even
just different programs.</p>
<p>:::</p>
<h3 id="declaration">Declaration</h3>
<p>The declaration expression <code>&lt;dec&gt;</code> has type
<code>T</code> provided the declaration <code>&lt;dec&gt;</code> has
type <code>T</code>.</p>
<p>Evaluating the expression <code>&lt;dec&gt;</code> proceeds by
evaluating <code>&lt;dec&gt;</code>, returning the result of
<code>&lt;dec&gt;</code> but discarding the bindings introduced by
<code>&lt;dec&gt;</code> (if any).</p>
<p>(The expression <code>&lt;dec&gt;</code> is actually shorthand for
the block expression <code>{ &lt;dec&gt; }</code>.)</p>
<h3 id="ignore">Ignore</h3>
<p>The expression <code>ignore &lt;exp&gt;</code> has type
<code>()</code> provided the expression <code>&lt;exp&gt;</code> has
type <code>Any</code> .</p>
<p>The expression <code>ignore &lt;exp&gt;</code> evaluates
<code>&lt;exp&gt;</code> (typically for some side-effect) but discards
its value.</p>
<p><code>Ignore</code> is useful for evaluating an expression within a
sequence of declarations when that expression has non-<code>unit</code>
type (and the simpler <code>&lt;exp&gt;</code> declaration would be
ill-typed). Then the semantics is equivalent to
<code>let _ = &lt;exp&gt; : Any</code>.</p>
<h3 id="debug">Debug</h3>
<p>The debug expression <code>debug &lt;block-or-exp&gt;</code> has type
<code>()</code> provided the expression
<code>&lt;block-or-exp&gt;</code> has type <code>()</code>.</p>
<p>When the program is compiled or interpreted with (default) flag
<code>--debug</code>, evaluating the expression
<code>debug &lt;exp&gt;</code> proceeds by evaluating
<code>&lt;block-or-exp&gt;</code>, returning the result of
<code>&lt;block-or-exp&gt;</code>.</p>
<p>When the program is compiled or interpreted with flag
<code>--release</code>, evaluating the expression
<code>debug &lt;exp&gt;</code> immediately returns the unit value
<code>()</code>. The code for <code>&lt;block-or-exp&gt;</code> is never
executed, nor is its code included in the compiled binary.</p>
<h3 id="actor-references">Actor references</h3>
<p>The actor reference <code>actor &lt;exp&gt;</code> has expected type
<code>T</code> provided:</p>
<ul>
<li><p>the expression is used in a context expecting an expression of
type <code>T</code> (typically as the subject of a type annotation,
typed declaration or function argument); and</p></li>
<li><p><code>T</code> is an some actor type <code>actor { …​ }</code>;
and</p></li>
<li><p><code>&lt;exp&gt;</code> has type <code>Text</code>.</p></li>
</ul>
<p>The argument <code>&lt;exp&gt;</code> must be, or evaluate to, the
textual format of an IC canister identifier (specified elsewhere),
otherwise the expression traps. The result of the expression is an actor
value representing that canister.</p>
<p>The validity of the canister identifier and its asserted type
<code>T</code> are promises and taken on trust.</p>
<p>An invalid canister identifier or type may manifest itself, if at
all, as a later dynamic failure when calling a function on the actor’s
proclaimed interface, which will either fail or be rejected.</p>
<p>:::note</p>
<p>The argument to <code>actor</code> should <em>not</em> include the
<code>ic:</code> resource locator used to specify an
<code>import</code>. For example, use <code>actor "lg264-qjkae"</code>,
not <code>actor "ic:lg264-qjkae"</code>.</p>
<p>:::</p>
<p>:::danger</p>
<p>Although they do not compromise type safety, actor references can
easily introduce latent, dynamic errors. Accordingly, actor references
should be used sparingly and only when needed.</p>
<p>:::</p>
<h3 id="parentheses">Parentheses</h3>
<p>The parenthesized expression <code>( &lt;exp&gt; )</code> has type
<code>T</code> provided <code>&lt;exp&gt;</code> has type
<code>T</code>.</p>
<p>The result of evaluating <code>( &lt;exp&gt; )</code> is the result
of evaluating <code>&lt;exp&gt;</code>.</p>
<h3 id="subsumption">Subsumption</h3>
<p>Whenever <code>&lt;exp&gt;</code> has type <code>T</code> and
<code>T &lt;: U</code> (<code>T</code> subtypes <code>U</code>) then by
virtue of <em>implicit subsumption</em>, <code>&lt;exp&gt;</code> also
has type <code>U</code> (without extra syntax).</p>
<p>In general, this means that an expression of a more specific type may
appear wherever an expression of a more general type is expected,
provided the specific and general types are related by subtyping. This
static change of type has no runtime cost.</p>
<h2 id="references">References</h2>
<ul>
<li><em>IEEE Standard for Floating-Point Arithmetic</em>, in IEEE Std
754-2019 (Revision of IEEE 754-2008), vol., no., pp.1-84, 22 July 2019,
doi: 10.1109/IEEESTD.2019.8766229.</li>
</ul>
</body>
</html>
