<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>md/local-objects-classes.md</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">md/local-objects-classes.md</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#local-objects-and-classes"
id="toc-local-objects-and-classes">Local objects and classes</a>
<ul>
<li><a href="#example-the-counter-object"
id="toc-example-the-counter-object">Example: The <code>counter</code>
object</a></li>
<li><a href="#object-types" id="toc-object-types">Object types</a></li>
<li><a href="#example-the-bytecounter-object"
id="toc-example-the-bytecounter-object">Example: The
<code>byteCounter</code> object</a></li>
<li><a href="#object-subtyping" id="toc-object-subtyping">Object
subtyping</a></li>
<li><a href="#object-classes" id="toc-object-classes">Object classes</a>
<ul>
<li><a href="#class-constructor" id="toc-class-constructor">Class
constructor</a></li>
</ul></li>
<li><a href="#structural-subtyping"
id="toc-structural-subtyping">Structural subtyping</a></li>
</ul></li>
</ul>
</nav>
<h1 id="local-objects-and-classes">Local objects and classes</h1>
<!--
TODO: Move examples into doc/modules/language-guide/examples
-->

<p>In Motoko, an <code>object</code> may encapsulate local state
(<code>var</code>-bound variables) by packaging this state with
<code>public</code> methods that access and update it.</p>
<p>As in other typed languages, Motoko programs benefit from the ability
to encapsulate state as objects with abstract types.</p>
<p>However, Motoko objects that include mutable state are <em>not
shareable</em>, and this is a critical security-oriented design
decision.</p>
<p>If they were shareable, that would mean either conceptually moving a
mobile object’s code among actors and executing it remotely, a security
risk, or sharing state with remote logic, another security risk.
(Notably, as a subcase, objects may be pure records and those
<em>are</em> shareable, since they are free from mutable state.)</p>
<p>To compensate for this necessary limitation, <code>actor</code>
objects <em>are shareable</em>, but always execute remotely. They
communicate with shareable Motoko data only. Local objects interact in
less restricted ways with themselves, and can pass any Motoko data to
each other’s methods, including other objects. In most other ways, local
objects (and classes) are non-shareable counterparts to actor objects
(and classes).</p>
<p>The <a href="mutable-state.md">Mutable state</a> introduced
declarations of private mutable state, in the form of
<code>var</code>-bound variables and (mutable) array allocation. In this
chapter, we use mutable state to implement simple objects, much like how
we would implement simple objects in object-oriented programming.</p>
<p>We illustrate this support via a running example, which continues in
the next chapter. The following example illustrates a general evolution
path for Motoko programs. Each <em>object</em>, if important enough, has
the potential to be refactored into an Internet <em>service</em>, by
refactoring this <em>(local) object</em> into an <em>actor
object</em>.</p>
<p><strong>Object classes</strong>. Frequently, one needs <em>a
family</em> of related objects to perform a task. When objects exhibit
similar behavior, it makes sense to fabricate them according to the same
blueprint, but with customizable initial state. To this end, Motoko
provides a syntactical construct, called a <code>class</code>
definition, which simplifies building objects of the same type and
implementation. We introduce these after discussing objects.</p>
<p><strong>Actor classes</strong>. When an object class exposes a <em><a
href="actors-async.md">service</a></em> (asynchronous behavior), the
corresponding Motoko construct is an <a href="actors-async.md">actor
class</a>, which follows a similar (but distinct) design.</p>
<h2 id="example-the-counter-object">Example: The <code>counter</code>
object</h2>
<p>Consider the following <em>object declaration</em> of the object
value <code>counter</code>:</p>
<pre class="motoko"><code>object counter {
  var count = 0;
  public func inc() { count += 1 };
  public func read() : Nat { count };
  public func bump() : Nat {
    inc();
    read()
  };
};</code></pre>
<p>This declaration introduces a single object instance named
<code>counter</code>, whose entire implementation is given above.</p>
<p>In this example, the developer exposes three <em>public</em>
functions <code>inc</code>, <code>read</code> and <code>bump</code>
using keyword <code>public</code> to declare each in the object body.
The body of the object, like a block expression, consists of a list of
declarations.</p>
<p>In addition to these three functions, the object has one (private)
mutable variable <code>count</code>, which holds the current count,
initially zero.</p>
<h2 id="object-types">Object types</h2>
<p>This object <code>counter</code> has the following <em>object
type</em>, written as a list of field-type pairs, enclosed in braces
(<code>{</code> and <code>}</code>):</p>
<pre class="motoko"><code>{
  inc  : () -&gt; () ;
  read : () -&gt; Nat ;
  bump : () -&gt; Nat ;
}</code></pre>
<p>Each field type consists of an identifier, a colon <code>:</code>,
and a type for the field content. Here, each field is a function, and
thus has an <em>arrow</em> type form (<code>_ → _</code>).</p>
<p>In the declaration of <code>object</code>, the variable
<code>count</code> was explicitly declared neither as
<code>public</code> nor as <code>private</code>.</p>
<p>By default, all declarations in an object block are
<code>private</code>, as is <code>count</code> here. Consequently, the
type for <code>count</code> does not appear in the type of the object,
<em>and</em> its name and presence are both inaccessible from the
outside.</p>
<p>The inaccessibility of this field comes with a powerful benefit: By
not exposing this implementation detail, the object has a <em>more
general</em> type (fewer fields), and as a result, is interchangeable
with objects that implement the same counter object type differently,
without using such a field.</p>
<h2 id="example-the-bytecounter-object">Example: The
<code>byteCounter</code> object</h2>
<p>To illustrate the point just above, consider this variation of the
<code>counter</code> declaration above, of <code>byteCounter</code>:</p>
<pre class="motoko"><code>import Nat8 &quot;mo:base/Nat8&quot;;
object byteCounter {
  var count : Nat8 = 0;
  public func inc() { count += 1 };
  public func read() : Nat { Nat8.toNat(count) };
  public func bump() : Nat { inc(); read() };
};</code></pre>
<p>This object has the same type as the previous one, and thus from the
standpoint of type checking, this object is interchangeable with the
prior one:</p>
<pre class="motoko"><code>{
  inc  : () -&gt; () ;
  read : () -&gt; Nat ;
  bump : () -&gt; Nat ;
}</code></pre>
<p>Unlike the first version, however, this version does not use the same
implementation of the counter field. Rather than use an ordinary natural
<code>Nat</code> that never overflows, but may also grow without bound,
this version uses a byte-sized natural number (type <code>Nat8</code>)
whose size is always eight bits.</p>
<p>As such, the <code>inc</code> operation may fail with an overflow for
this object, but never the prior one, which may instead (eventually)
fill the program’s memory, a different kind of application failure.</p>
<p>Neither implementation of a counter comes without some complexity,
but in this case, they share a common type.</p>
<p>In general, a common type shared among two implementations (of an
object or service) affords the potential for the internal implementation
complexity to be factored away from the rest of the application that
uses it. Here, the common type abstracts over the simple choice of a
number’s representation. In general, the implementation choices would
each be more complex, and more interesting.</p>
<h2 id="object-subtyping">Object subtyping</h2>
<p>To illustrate the role and use of object subtyping in Motoko,
consider implementing a simpler counter with a more general type (fewer
public operations):</p>
<pre class="motoko"><code>object bumpCounter {
  var c = 0;
  public func bump() : Nat {
    c += 1;
    c
  };
};</code></pre>
<p>The object <code>bumpCounter</code> has the following object type,
exposing exactly one operation, <code>bump</code>:</p>
<pre class="motoko"><code>{
  bump : () -&gt; Nat ;
}</code></pre>
<p>This type exposes the most common operation, and one that only
permits certain behavior. For instance, the counter can only ever
increase, and can never decrease or be set to an arbitrary value.</p>
<p>In other parts of a system, we may in fact implement and use a
<em>less general</em> version, with <em>more</em> operations:</p>
<pre class="motoko"><code>fullCounter : {
  inc   : () -&gt; () ;
  read  : () -&gt; Nat ;
  bump  : () -&gt; Nat ;
  write : Nat -&gt; () ;
}</code></pre>
<p>Here, we consider a counter named <code>fullCounter</code> with a
less general type than any given above. In addition to <code>inc</code>,
<code>read</code> and <code>bump</code>, it additionally includes
<code>write</code>, which permits the caller to change the current count
value to an arbitrary one, such as back to <code>0</code>.</p>
<p><strong>Object subtyping.</strong> In Motoko, objects have types that
may relate by subtyping, as the various types of counters do above. As
is standard, types with <em>more fields</em> are <em>less general</em>
(are <em><strong>sub</strong>types</em> of) types with <em>fewer
fields</em>. For instance, we can summarize the types given in the
examples above as being related in the following subtyping order:</p>
<ul>
<li>Most general:</li>
</ul>
<pre class="motoko"><code>{ bump : () -&gt; Nat }</code></pre>
<ul>
<li>Middle generality:</li>
</ul>
<pre class="motoko"><code>{
  inc  : () -&gt; () ;
  read : () -&gt; Nat ;
  bump : () -&gt; Nat ;
}</code></pre>
<ul>
<li>Least generality:</li>
</ul>
<pre class="motoko"><code>{
  inc  : () -&gt; () ;
  read : () -&gt; Nat ;
  bump : () -&gt; Nat ;
  write : Nat -&gt; () ;
}</code></pre>
<p>If a function expects to receive an object of the first type
(<code>{ bump: () → Nat }</code>), <em>any</em> of the types given above
will suffice, since they are each equal to, or a subtype of, this (most
general) type.</p>
<p>However, if a function expects to receive an object of the last,
least general type, the other two will <em>not</em> suffice, since they
each lack the needed <code>write</code> operation, to which this
function rightfully expects to have access.</p>
<h2 id="object-classes">Object classes</h2>
<p>In Motoko, an object encapsulates state, and an object
<code>class</code> is a package of two entities that share a common
name.</p>
<p>Consider this example <code>class</code> for counters that start at
zero:</p>
<pre class="motoko"><code>class Counter() {
  var c = 0;
  public func inc() : Nat {
    c += 1;
    return c;
  }
};</code></pre>
<p>The value of this definition is that we can <em>construct</em> new
counters, each starting with their own unique state, initially at
zero:</p>
<pre class="motoko"><code>let c1 = Counter();
let c2 = Counter();</code></pre>
<p>Each is independent:</p>
<pre class="motoko"><code>let x = c1.inc();
let y = c2.inc();
(x, y)</code></pre>
<p>We could achieve the same results by writing a function that returns
an object:</p>
<pre class="motoko"><code>func Counter() : { inc : () -&gt; Nat } =
  object {
    var c = 0;
    public func inc() : Nat { c += 1; c }
  };</code></pre>
<p>Notice the return type of this <em>constructor function</em> (an
object type):</p>
<pre class="motoko"><code>{ inc : () -&gt; Nat }</code></pre>
<p>We may want to name this type, for example, <code>Counter</code>, as
follows, for use in further type declarations:</p>
<pre class="motoko"><code>type Counter = { inc : () -&gt; Nat };</code></pre>
<p>In fact, the <code>class</code> keyword syntax shown above is nothing
but a shorthand for these two definitions for <code>Counter</code>: a
factory function <code>Counter</code> that constructs objects, and the
type <code>Counter</code> of these objects. Classes do not provide any
new functionality beyond this convenience.</p>
<h3 id="class-constructor">Class constructor</h3>
<p>An object class defines a constructor function that may carry zero or
more data arguments and zero or more type arguments.</p>
<p>The <code>Counter</code> example above has zero of each.</p>
<p>The type arguments, if any, parameterize both the type and the
constructor function for the class.</p>
<p>The data arguments, if any, parameterize (only) the constructor
function for the class.</p>
<h4 id="data-arguments">Data arguments</h4>
<p>Suppose we want to initialize the counter with some non-zero value.
We can supply that value as a data argument to the <code>class</code>
constructor:</p>
<pre class="motoko"><code>class Counter(init : Nat) {
  var c = init;
  public func inc() : Nat { c += 1; c };
};</code></pre>
<p>This parameter is available to all methods.</p>
<p>For instance, we can <code>reset</code> the <code>Counter</code> to
its initial value, a parameter:</p>
<pre class="motoko"><code>class Counter(init : Nat) {
  var c = init;
  public func inc() : Nat { c += 1; c };
  public func reset() { c := init };
};</code></pre>
<h4 id="type-arguments">Type arguments</h4>
<p>Suppose we want the counter to actually carry data that it counts
(like a specialized <code>Buffer</code>).</p>
<p>When classes use or contain data of arbitrary type, they carry a type
argument (or equivalently, <em>type parameter</em>) for that unknown
type, just as with functions.</p>
<p>The scope of this type parameter covers the entire
<code>class</code>, just as with data parameters. As such, the methods
of the class can use (and <em>need not re-introduce</em>) these type
parameters.</p>
<pre class="motoko"><code>import Buffer &quot;mo:base/Buffer&quot;;

class Counter&lt;X&gt;(init : Buffer.Buffer&lt;X&gt;) {
  var buffer = init.clone();
  public func add(x : X) : Nat {
    buffer.add(x);
    buffer.size()
  };

  public func reset() {
    buffer := init.clone()
  };
};</code></pre>
<h4 id="type-annotation">Type annotation</h4>
<p>Optionally, the class constructor may also carry a type annotation
for its "return type" (the type of objects that it produces). When
supplied, Motoko checks that this type annotation is compatible with the
body of the class (an object definition). This check ensures that each
object produced by the constructor meets the supplied specification.</p>
<p>For example, we repeat the <code>Counter</code> as a buffer, and
annotate it with a more general type <code>Accum&lt;X&gt;</code> that
permits adding, but not resetting the counter. This annotation ensures
that the objects are compatible with the type
<code>Accum&lt;X&gt;</code>.</p>
<pre class="motoko"><code>import Buffer &quot;mo:base/Buffer&quot;;

type Accum&lt;X&gt; = { add : X -&gt; Nat };

class Counter&lt;X&gt;(init : Buffer.Buffer&lt;X&gt;) : Accum&lt;X&gt; {
  var buffer = init.clone();
  public func add(x : X) : Nat { buffer.add(x); buffer.size() };
  public func reset() { buffer := init.clone() };
};</code></pre>
<h4 id="full-syntax">Full syntax</h4>
<p>In full, classes are defined by the keyword <code>class</code>,
followed by: - a name for the constructor and type being defined (for
example, <code>Counter</code>) - optional type arguments (for example,
omitted, or <code>&lt;X&gt;</code>, or <code>&lt;X, Y&gt;</code>) - an
argument list (for example, <code>()</code>, or
<code>(init : Nat)</code>, etc.) - an optional type annotation for the
constructed objects (for example, omitted, or
<code>Accum&lt;X&gt;</code>), - the class "body" is an object
definition, parameterized by the type and value arguments (if any).</p>
<p>The constituents of the body marked <code>public</code> contribute to
the resulting objects' type and these types compared against the
(optional) annotation, if given.</p>
<h5 id="another-example-bits">Another example: <code>Bits</code></h5>
<p>As another example, let’s consider the task of walking the bits of a
natural number (type <code>Nat</code>). For this example, we could
define the following:</p>
<pre class="motoko"><code>class Bits(n : Nat) {
  var state = n;
  public func next() : ?Bool {
    if (state == 0) { return null };
    let prev = state;
    state /= 2;
    ?(state * 2 != prev)
  }
}</code></pre>
<p>The above class definition is equivalent to the simultaneous
definition of a structural type synonym and a factory function, both
named <code>Bits</code>:</p>
<pre class="motoko"><code>type Bits = {next : () -&gt; ?Bool};
func Bits(n : Nat) : Bits = object {
  // class body
};</code></pre>
<h2 id="structural-subtyping">Structural subtyping</h2>
<p>Object subtyping in Motoko uses <em>structural subtyping</em>, not
<em>nominal subtyping</em>.</p>
<p>Recall that in nominal typing, the question of two types equality
depends on choosing consistent, globally-unique type names (across
projects and time).</p>
<p>In Motoko, the question of two types' equality is based on their
<em>structure</em>, not their names.</p>
<p>Due to structural typing, naming the class type provides a convenient
abbreviation.</p>
<p>For typing purposes, however, all that matters is the
<em>structure</em> of the corresponding object type: two classes with
different names but equivalent definitions produce type-compatible
objects.</p>
<p>When the optional type annotation is supplied in a class declaration,
conformance is checked: the object type must be a subtype of the
annotation. The annotation does not affect the type of the class,
however, even if it only describes a proper super-type of the object
type.</p>
<p>Formally, subtyping relationships in Motoko extend to all types, not
just object types.</p>
<p>Most cases are standard, and follow conventional programming language
theory (for <em>structural</em> subtyping, specifically).</p>
<p>Other notable cases in Motoko for new programmers include array,
options, variants and number type inter-relationships.</p>
</body>
</html>
