<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>md/style.md</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">md/style.md</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#motoko-style-guidelines"
id="toc-motoko-style-guidelines">Motoko style guidelines</a>
<ul>
<li><a href="#layout" id="toc-layout">Layout</a>
<ul>
<li><a href="#spacing" id="toc-spacing">Spacing</a></li>
<li><a href="#line-breaks" id="toc-line-breaks">Line breaks</a></li>
<li><a href="#indentation" id="toc-indentation">Indentation</a></li>
<li><a href="#grouping" id="toc-grouping">Grouping</a></li>
<li><a href="#comments" id="toc-comments">Comments</a></li>
</ul></li>
<li><a href="#punctuation" id="toc-punctuation">Punctuation</a>
<ul>
<li><a href="#semicolons" id="toc-semicolons">Semicolons</a></li>
<li><a href="#braces" id="toc-braces">Braces</a></li>
<li><a href="#parentheses" id="toc-parentheses">Parentheses</a></li>
<li><a href="#miscellaneous"
id="toc-miscellaneous">Miscellaneous</a></li>
</ul></li>
<li><a href="#naming" id="toc-naming">Naming</a>
<ul>
<li><a href="#style" id="toc-style">Style</a></li>
<li><a href="#conventions" id="toc-conventions">Conventions</a></li>
</ul></li>
<li><a href="#types" id="toc-types">Types</a>
<ul>
<li><a href="#type-annotations" id="toc-type-annotations">Type
Annotations</a></li>
<li><a href="#picking-types" id="toc-picking-types">Picking
types</a></li>
</ul></li>
<li><a href="#features" id="toc-features">Features</a>
<ul>
<li><a href="#statements" id="toc-statements">Statements</a></li>
<li><a href="#objects-and-records" id="toc-objects-and-records">Objects
and records</a></li>
<li><a href="#classes" id="toc-classes">Classes</a></li>
<li><a href="#modules" id="toc-modules">Modules</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="motoko-style-guidelines">Motoko style guidelines</h1>
<p>To increase readability and uniformity of Motoko source code, the
style guide provides suggestions for formatting Motoko sources and other
basic conventions.</p>
<h2 id="layout">Layout</h2>
<h3 id="spacing">Spacing</h3>
<ul>
<li><p>Put spaces around arithmetic operators, except to visually group
sub-expressions of more tightly binding operators.</p>
<pre class="motoko"><code>let z = - 2*x + 3*y + 4*(x*x + y*y);</code></pre></li>
<li><p>Put spaces around comparison operators, Boolean operators, and
assignment operators.</p>
<pre class="motoko"><code>4 + 5 &lt;= 5 + 4;
not (a or b and not c);
v := 0;
v += 1;</code></pre></li>
<li><p>Put spaces around '='.</p>
<pre class="motoko"><code>var v = 0;
let r = { a = 1; b = 2 };</code></pre></li>
<li><p>Analogously, put spaces around <code>:</code>.</p>
<pre class="motoko"><code>var v : Nat = 0;
func foo(x : Nat, y : Nat) : Nat { x + y }
func bar((x, y) : (Nat, Nat)) : Nat { x + y }
let w = 1 ^ 0xff : Nat16;</code></pre>
<p>Rationale: ':' is to declarations what '=' is to definitions.
Moreover, the left-hand of a type annotation may generally be an
arbitrary complex expression or pattern.</p></li>
<li><p>Put a space after a comma or semicolon (but not before).</p>
<pre class="motoko"><code>let tuple = (1, 2, 3);
let record = { a = 1; b = 2; c = 3 };</code></pre></li>
<li><p>Put spaces inside braces, unless they are a simple variant or
record.</p>
<pre class="motoko"><code>func f() { 0 };
f({ a = 1; b = 2; c = 3 });
f({a = 1; b = 2});  // okay as well

type Vec3D = { x : Float; y : Float; y : Float };
type Order = { #less; #equal; #more };

type Order = {#less; #equal; #more};  // okay as well
type Proc = {h : Nat; w : Nat} -&gt; {#ok; #fail};</code></pre></li>
<li><p>Put spaces inside brackets if they stretch multiple lines.</p>
<pre class="motoko"><code>foo(
  firstArgument,
  ( longTupleComponent, anotherLongExpression,
    moreLongExpression
  ),
  [ 1, 2, 3,
    4, 5, 6,
  ],
  { field1 = 4; field2 = 5;
    field3 = 6;
  }
);</code></pre></li>
<li><p>Put a space between statement keywords and their operands.</p>
<pre class="motoko"><code>if (f()) A else B;
for (x in xs.vals()) { ... };
switch (compare(x, y)) {
  case (#less) { A };
  case (_) { B };
}

assert (x &lt; 100);
await (async (0));</code></pre></li>
<li><p>Do <em>not</em> put a space between a function or variant tag and
its argument tuple or around a generic type parameter list.</p>
<pre class="motoko"><code>type Pair&lt;X&gt; = (X, X);
type Id = &lt;X&gt;(X) -&gt; X;

let ok = #ok(5);

func id&lt;X&gt;(x : X) : X { x };
id&lt;Nat&gt;(5);</code></pre></li>
<li><p>Put a space between a function and its argument if it is
<em>not</em> a tuple or parenthesized expression (see <a
href="#parentheses">Parentheses</a>) or a record used as a named
parameter list (see <a href="#picking-types">Picking types</a>).</p>
<pre class="motoko"><code>sin 0.0;
g [1, 2, 3];
f{arg1 = 0; arg2 = 0};</code></pre></li>
</ul>
<p>Rationale: <code>g[1]</code> in particular will be misparsed as an
indexing operation.</p>
<ul>
<li><p>Do <em>not</em> put a space around access operators like
<code>.</code>, <code>?</code>, <code>!</code>, or index brackets.</p>
<pre class="motoko"><code>foo(bar).baz[5]().boo;
foom(?(bam()! + 1));</code></pre></li>
</ul>
<h3 id="line-breaks">Line breaks</h3>
<ul>
<li><p>Pick a fixed right margin for lines and break definitions or
expressions that are longer than that (80 still is considered a good
limit by many).</p>
<pre class="motoko"><code>let sum = a + b + 2*c + d +
  e + f + g + h + i + k +
  l + m + n + o + p;

// Or:
let sum =
  a + b + 2*c + d + e +
  f + g + h + i + k + l +
  m + n + o + p;</code></pre>
<p>Rationale: Among other reasons, this style of formatting:</p>
<ol type="1">
<li><p>Avoids code being hidden to the right in a window.</p></li>
<li><p>Avoids random line breaks in side-by-side diffs (for example, as
shown by GitHub or similar code review tools).</p></li>
<li><p>Allows prettier display on paper, web sites, or other
media.</p></li>
</ol></li>
<li><p>Break lines <em>after</em> an operator.</p>
<pre class="motoko"><code>a + b + c +
  d + f;

foo(bar, baz).
  boo();</code></pre></li>
<li><p>When breaking function definitions or calls with long argument
lists, put each argument on a separate line.</p>
<p>Also, consider using records for long parameter lists, see <a
href="#picking-types">Picking types</a>.</p>
<pre class="motoko"><code>func someFunction(
  arg1 : FirstType,
  arg2 : SecondType,
  anotherArg : Nat,
  yetAnother : [Type],
  func : Nat -&gt; Nat,
) : Nat {
  ...
};

someFunction(
  veryLongArgumentExpression,
  anotherVeryLongArgumentExpression,
  3,
  aNestedFunctionCall(
    alsoWithLongArguments,
    andMoreSuchArguments,
  ),
  moreLongishArgument,
);</code></pre>
<p>Rationale: This prevents overlooking an argument when reading code
and avoids re-breaking lines when changing one of the
expressions.</p></li>
</ul>
<h3 id="indentation">Indentation</h3>
<ul>
<li><p>Each level of indentation should be 2 spaces.</p>
<pre class="motoko"><code>actor A {
  public func f() {
    return;
  }
}</code></pre>
<p>Rationale: There may be a lot of nesting. Using only 2 spaces avoids
wasting screen estate.</p></li>
<li><p>Indentation should not depend on the lexical contents of previous
lines.</p>
<p>In particular, do not vertically align indentation with inner
characters from previous lines.</p>
<pre class="motoko"><code>let x = someFunction(
  arg1, arg2, arg3, arg4, arg5);               // Do this.

let x = someFunction(arg1, arg2, arg3,
  arg4, arg5);                                 // Or this.

let x =
  someFunction(arg1, arg2, arg3, arg4, arg5);  // Or this.

let x = someFunction(                          // Or this.
  longArg1,
  longArg2,
  longArg3,
  longArg4,
  longArg5,
);

// COUNTER EXAMPLE!
let x = someFunction(arg1, arg2, arg3,
                     arg4, arg5);              // DO NOT DO THIS!</code></pre>
<p>Rationale: There are many problems with vertical alignment, for
example:</p>
<ol type="1">
<li><p>It wastes a lot of horizontal space.</p></li>
<li><p>It creates wildly inconsistent indentation levels that obfuscate
the structure of the code.</p></li>
<li><p>It can produce realignment churn when changing a line, which
(even when automated by editors) inflates and obfuscates diffs.</p></li>
<li><p>It completely breaks with variable-width fonts.</p></li>
</ol>
<p>Rule of thumb: there should be no indentation that is not a multiple
of 2.</p></li>
<li><p>Do not use tabs.</p>
<p>Rationale: The interpretation of tabs varies wildly across tools and
they get lost or are displayed incorrectly in many contexts, such as web
pages, diffs, etc.</p></li>
</ul>
<h3 id="grouping">Grouping</h3>
<ul>
<li><p>Separate complex multi-line definitions with empty lines.
One-liners can be put on consecutive lines.</p>
<pre class="motoko"><code>func foo() {
  // This function does a lot of interesting stuff.
  // It&#39;s definition takes multiple lines.
}

func boo() {
  // This is another complicated function.
  // It&#39;s definition also takes multiple lines.
}

func add(x : Nat, y : Nat) { return x + y };
func mul(x : Nat, y : Nat) { return x * y };</code></pre></li>
<li><p>Separate logic groups of definitions with two empty lines. Add a
one-line comment as a "section header" for each group.</p>
<pre class="motoko"><code>// A very large class
class MuffleMiff(n : Nat) {


  // Accessors

  public func miffMuff() : Text {
    ...
  }

  public func sniffMiff() : Nat {
    ...
  }


  // Mutators

  public func clearMurk() {
    ...
  }

  public func addMuff(name : Text) {
    ...
  }


  // Processing

  public func murkMuffle(param : List&lt;Gnobble&gt;) {
    ...
  }

  public func transformSneezler() {
    ...
  }


  // Internal State

  var miffCount = 0;
  var mabbleMap = Map&lt;Nat, Text&gt;();

}</code></pre></li>
</ul>
<h3 id="comments">Comments</h3>
<ul>
<li><p>Use line comments (<code>//…​</code>). Use block comments
(<code>/* …​ */</code>) only when commenting in the middle of a line or
for commenting out pieces of code during development.</p>
<pre class="motoko"><code>// The following function runs the current
// pallaboom on a given snibble. It returns
// suitable plexus if it can.
func paBoom(s : Snibble) : Handle&lt;Plexus&gt; {
  let puglet = initPugs(s.crick, 0 /* size */, #local);
/* Don&#39;t do the odd stuff yet...
  ...
  ...
*/
  return polyfillNexus(puglet);  // for now
}</code></pre>
<p>Rationale: Line comments make it easier to insert, remove or swap
individual lines.</p></li>
<li><p>Put short comments explaining a single line at the end of the
line, separated by at least 2 spaces.</p>
<pre class="motoko"><code>paBoom(getSnibble()));  // create new snibble</code></pre></li>
<li><p>Put multi-line comments before a line of code, with the same
indentation as the code it is describing.</p>
<pre class="motoko"><code>func f() {
  // Try to invoke the current pallaboom with
  // the previous snibble. If that succeeds,
  // we have the new plexus; if not, complain.
  let plexusHandle = paBoom(getSnibble()));
}</code></pre></li>
<li><p>Capitalize comments that are on separate lines. Use a proper full
stop for sentences.</p></li>
</ul>
<h2 id="punctuation">Punctuation</h2>
<h3 id="semicolons">Semicolons</h3>
<ul>
<li><p>Motoko uniformly requires a semicolon to separate expressions or
local declarations in a block, regardless of whether the preceding
declaration ends in a closing '}'.</p>
<p>Rationale: This is unlike other C-style languages, which tend to have
rather ad-hoc rules.</p></li>
<li><p>Put a semicolon after the last expression in a block, unless the
whole block is written on a single line.</p>
<p>Similarly for types.</p>
<pre class="motoko"><code>// No ; needed before closing } on same line

type Vec3D = {x : Float; y : Float; z : Float};
type Result&lt;A&gt; = {#ok : A; #error : Text};

func add(x : Nat, y : Nat) : Nat { return x + y };


// End last case with ;

type Address = {
  first : Text;
  last : Text;
  street : Text;
  nr : Nat;
  zip : Nat;
  city : Text;
};

type Expr = {
  #const : Float;
  #add : (Expr, Expr);
  #mul : (Expr, Expr);
};

func eval(e : Expr) : Float {
  switch (e) {
    case (#const(x)) { x };
    case (#add(e1, e2)) { eval(e1) + eval(e2) };
    case (#mul(e1, e2)) { eval(e1) * eval(e2) };
  };
}</code></pre>
<p>Rationale: Consistently ending lines with semicolon simplifies
adding, removing, or swapping lines.</p></li>
</ul>
<h3 id="braces">Braces</h3>
<ul>
<li><p>Put braces around function bodies, <code>if</code> or
<code>case</code> branches, and loop bodies, unless they appear nested
as an expression and only contain a single expression.</p>
<pre class="motoko"><code>func f(x) { f1(x); f2(x) };

let abs = if (v &gt;= 0) v else -v;
let val = switch (f()) { case (#ok(x)) x; case (_) 0 };
func succ(x : Nat) : Nat = x + 1;</code></pre></li>
<li><p>Use "C-style" layout for braced sub-expressions stretching
multiple lines.</p>
<pre class="motoko"><code>func f() {
  return;
};

if (cond) {
  foo();
} else {
  bar();
};

switch (opt) {
  case (?x) {
    f(x);
  };
  case (null) {};
};</code></pre></li>
</ul>
<h3 id="parentheses">Parentheses</h3>
<ul>
<li><p>Motoko supports "parenless" style, meaning that parentheses are
optional in most places, such as function parameter lists, or statement
operands, when they enclose an expression that either is bracketed
already (for example, a tuple, object, or array) or is a simple constant
or identifier.</p>
<pre class="motoko"><code>type Op = Nat -&gt; Nat;
let a2 = Array.map&lt;Nat, Nat&gt;(func x { x + 1 }, a);

let y = f x;
let z = f {};
let choice = if flag { f1() } else { f2() };

switch opt {
  case null { tryAgain() };
  case _ { proceed() };
};</code></pre></li>
<li><p>Avoid overuse of parenless style.</p>
<p>In particular, do not omit parentheses and braces on statements at
the same time.</p>
<pre class="motoko"><code>// COUNTER EXAMPLES!
let choice = if flag x + y else z;  // DO NOT DO THIS!

switch val {
  case 0 f();    // DO NOT DO THIS!
  case n n + 1;  // OR THIS!
};</code></pre>
<p>Rationale: Omitting both at the same time makes the code harder to
read, since there is less visual clue how it groups.</p></li>
<li><p>Similarly, do not omit parentheses around function parameters if
the function also has type parameters.</p>
<pre class="motoko"><code>// COUNTER EXAMPLE!
foo&lt;Nat&gt; 0;   // DO NOT DO THIS!</code></pre></li>
<li><p>Omit parentheses around argument types of a function type with a
single argument and no type parameters.</p>
<p>But do not omit them around when functions or classes also have type
parameters.</p>
<pre class="motoko"><code>type Inv = Nat -&gt; Nat;
type Id = &lt;T&gt;(T) -&gt; T;
type Get = &lt;X&gt;(C&lt;X&gt;) -&gt; X;

// COUNTER EXAMPLE!
type Get = &lt;X&gt;C&lt;X&gt; -&gt; X;   // DO NOT DO THIS!</code></pre></li>
</ul>
<h3 id="miscellaneous">Miscellaneous</h3>
<ul>
<li><p>Use <code>_</code> to group digits in numbers.</p>
<p>Group by 3 digits in decimal numbers and by 4 in hexadecimal
notation.</p>
<pre class="motoko"><code>let billion = 1_000_000_000;
let pi = 3.141_592_653_589_793_12;
let mask : Nat32 = 0xff00_ff0f;</code></pre></li>
</ul>
<h2 id="naming">Naming</h2>
<h3 id="style">Style</h3>
<ul>
<li><p>Use <code>UpperCamelCase</code> for type names (including classes
or type parameters), module names, and actor names.</p></li>
<li><p>Use <code>lowerCamelCase</code> for all other names, including
constants and variant fields.</p>
<pre class="motoko"><code>module MoreMuff {
  type FileSize = Nat;
  type Weekday = {#monday; #tuesday; #wednesday};
  type Pair&lt;X&gt; = (X, X);

  class Container&lt;X, Y&gt;() { ... };

  func getValue&lt;Name&gt;(name : Name) : Pair&lt;Name&gt; { ... };

  let zero = 0;
  let pair = getValue&lt;Text&gt;(&quot;opus&quot;);
  var nifty : Nat = 0;

  object obj { ... };

  actor ServerProxy { ... };
};</code></pre>
<p>Rationale: The general convention is upper case for "static" entities
like types and lower case for "dynamic" values. Modules and actors are
fairly static and can export types. Objects usually don’t export types
and tend to be used mostly as dynamic values.</p></li>
<li><p>Spell acronyms as regular words.</p>
<pre class="motoko"><code>type HttpHeader = ...;
func getUrl() { ... };
let urlDigest = ...;</code></pre></li>
<li><p>Do not use identifier names that start with an underscore
<code>_</code>, except to document that a variable in a pattern is
intentionally unused.</p>
<pre class="motoko"><code>let (width, _color, name) = rumpler();
...  // _color is not used here


func foo(x : Nat, _futureFlag : Bool) { ... };</code></pre>
<p>Rationale: A type checker can warn about unused identifiers, which
can be suppressed by explicitly prepending <code>_</code> to its name to
document intention.</p>
<p>This aligns with the use of the keyword <code>_</code> for pattern
wildcards.</p></li>
</ul>
<h3 id="conventions">Conventions</h3>
<ul>
<li><p>The name of functions returning a value should describe that
value (as a noun).</p>
<p>Avoid redundant <code>get</code> prefixes.</p>
<pre class="motoko"><code>dict.size();
list.first();
sum(array);</code></pre></li>
<li><p>The name of functions performing side effects or complex
operations should describe that operation (as a verb in imperative
form).</p>
<pre class="motoko"><code>dict.clear();
dict.set(key, value);
let result = traverse(graph);</code></pre></li>
<li><p>The name of predicate functions returning <code>Bool</code>
should use an <code>is</code> or <code>has</code> prefix or a similar
description of the tested property (as a verb in indicative form).</p>
<pre class="motoko"><code>class Set&lt;X&gt;() {
  public func size() : Nat { ... };

  public func add(x : X) { ... };
  public func remove(x : X) { ... };

  public func isEmpty() : Bool { ... };
  public func contains(x : X) : Bool { ... };
};</code></pre></li>
<li><p>Functions converting to or from a type <code>X</code> are named
<code>toX</code> and <code>fromX</code>, respectively, if the source,
resp. target, is either the object the function is a method of, or the
primary type of the module this function appears in.</p></li>
<li><p>In classes or objects, use a name ending with <code>_</code> to
distinguish private variables from getters.</p>
<pre class="motoko"><code>class Cart(length_ : Nat) {
  var width_ = 0;

  public func length() : Nat { return length_ };
  public func width() : Nat { return width_ };
}</code></pre>
<p>Rationale: In Motoko, functions are first-class values, so functions
and other value identifiers share the same name space.</p>
<p>Identifiers with a leading <code>_</code> should <em>not</em> be used
for private state, since that indicates an unused name (see <a
href="#style">Style</a>).</p></li>
<li><p>Use longer, more descriptive names for global or public
identifier or ones with large scope, and short names for local ones with
small scope.</p>
<p>It is fine to use single character identifiers when there is nothing
interesting to say, especially when using the same naming scheme
consistently.</p>
<pre class="motoko"><code>func map(x : Nat, y : Nat) : Nat { x + y };

func eval(e : Expr) : Nat {
  let n =
    switch (e) {
      case (#neg(e1)) { - eval(e1) };
      case (#add(e1, e2)) { eval(e1) + eval(e2) };
      case (#mul(e1, e2)) { eval(e1) * eval(e2) };
    };
  Debug.print(n);
  return n;
};</code></pre>
<p>Rationale: Contrary to popular belief, overly chatty local names can
decrease readability instead of increasing it, by increasing the noise
level.</p></li>
<li><p>In suitable cases, use plural form for describing a collection of
items, such as a list or array.</p>
<p>This also works for short names.</p>
<pre class="motoko"><code>func foreach&lt;X&gt;(xs : [X], f : X -&gt; ()) {
  for (x in xs.vals()) { f(x) }
}</code></pre></li>
</ul>
<h2 id="types">Types</h2>
<h3 id="type-annotations">Type Annotations</h3>
<ul>
<li><p>Put type annotations on definitions that involve fixed-width
numeric types, to disambiguate the type of overloaded arithmetic
operators and constants.</p>
<pre class="motoko"><code>let mask : Nat32 = 0xfc03_ff00;
let pivot : Nat32 = (size + 1)/2;
let vec : [Int16] = [1, 3, -4, 0];</code></pre>
<p>:::note</p>
<p>Use floating point constants to enforce type <code>Float</code>
without an extra annotation. Similarly, use an explicit <code>+</code>
sign to produce a positive value of type <code>Int</code> instead of
<code>Nat</code>, if desired.</p>
<p>:::</p>
<pre class="motoko"><code>let zero = 1.0;    // type Float
let offset = +1;   // type Int</code></pre></li>
<li><p>Similarly, put inline type annotations on arithmetic expressions
with types other than <code>Nat</code> or <code>Int</code>.</p>
<pre class="motoko"><code>if (x &amp; mask == (1 : Nat32)) { ... };</code></pre>
<p>:::note</p>
<p>The need to annotate constants in cases like this is a short-coming
of Motoko’s type system that we hope to address soon.</p>
<p>:::</p>
<p>An annotation is not needed on function arguments, since their type
is usually inferred from the function. The only exception is when that
argument has generic type and the type arguments have been omitted.</p>
<pre class="motoko"><code>func foo(len : Nat32, vec : [Nat16]) { ... };
func bar&lt;X&gt;(x : X) { ... };

foo(3, [0, 1, 2]);
bar&lt;Nat16&gt;(0);
bar(0 : Nat16);</code></pre></li>
<li><p>Put type annotations on mutable variables, unless their type is
obvious.</p>
<pre class="motoko"><code>var name = &quot;Motoko&quot;;
var balance = 0;

func f(i : Int) {
  var j = i;
};

var balance : Int = 0;
var obj : Class = foo();</code></pre>
<p>Rationale: Due to subtyping, inferring the type from the
initialisation would not necessarily deduce the intended type. For
example, <code>balance</code> would have type <code>Nat</code> without
the annotation, ruling out assignments of integers.</p></li>
<li><p>Put type annotations on all public fields in a class.</p>
<pre class="motoko"><code>class C(init_ : Nat) {
  public let init : Nat = init_;
  public var count : Nat = 0;
}</code></pre></li>
<li><p>Omit return type annotations of functions when the type is
<code>()</code>.</p>
<pre class="motoko"><code>func twiceF() { f(); f() };  // no need to write &quot;: ()&quot;</code></pre></li>
<li><p>Omit type annotations on functions when they are passed as
arguments.</p>
<pre class="motoko"><code>Array.map&lt;Nat, Nat&gt;(func n {n + 1}, a);</code></pre></li>
<li><p>Put type annotations on definitions that involve numeric types
other than <code>Nat</code> or <code>Int</code>, to resolve the
overloading between arithmetic operators and constants.</p>
<pre class="motoko"><code>let mask : Nat32 = 0xfc03_ff00;
let offset : Nat32 = size + 1;</code></pre></li>
</ul>
<h3 id="picking-types">Picking types</h3>
<ul>
<li><p>Use <code>Nat</code> for any integral value that cannot be
negative.</p></li>
<li><p>Use fixed-width <code>NatN</code> or <code>IntN</code> only when
storing many values and space usage matters, when bit-fiddling requires
the low-level interpretation of a number as a vector of bits or when
matching types imposed by external requirements, such as other
canisters.</p></li>
<li><p>Avoid proliferation of option types, and therefore
<code>null</code>.</p>
<p>Limit their use to as small a scope as possible. Rule out the
<code>null</code> case and use non-option types wherever
possible.</p></li>
<li><p>Consider using records (objects with just data) instead of tuples
when there are more than 2 or 3 components.</p>
<p>Note that record types need not be declared but can be used in
place.</p>
<pre class="motoko"><code>  func nodeInfo(node : Node) : {parent : Node; left : Node; right : Node} { ... }</code></pre></li>
<li><p>Consider using variants instead of <code>Bool</code> to represent
binary choices.</p>
<p>Note that variant types need not be declared but can be used in
place.</p>
<pre class="motoko"><code>func capitalization(word : Text) : {#upper; #lower} { ... }</code></pre></li>
<li><p>Where possible, use return type <code>()</code> for functions
whose primary purpose is to mutate state or cause other side
effects.</p>
<pre class="motoko"><code>class Set&lt;X&gt;() {
  public func add(x : X) { ... };
  public func remove(x : X) { ... };
  ...
};</code></pre></li>
<li><p>Consider using a record (an object with just data) as argument
for long parameter lists.</p>
<pre class="motoko"><code>func process({seed : Float; delta : Float; data : [Record]; config : Config}) : Thing {
  ...
};

process{config = Config(); data = read(); delta = 0.01; seed = 1.0};</code></pre>
<p>Rationale: This expresses named parameters. This way, arguments can
be freely reordered at the call site and callers are prevented from
accidentally passing them in the wrong order.</p></li>
<li><p>Higher-order functions (functions that take a callback argument)
should put the function parameter last.</p>
<p>Rationale: Makes call sites more readable, and in the absence of
currying, there is no point in putting the function first, like you
often would in functional languages.</p></li>
<li><p>Do not use sentinel values, such as <code>-1</code>, to represent
invalid values.</p>
<p>Use the option type instead.</p>
<pre class="motoko"><code>func lookup(x : key) : ?Nat { ... }</code></pre></li>
<li><p>Data is immutable in Motoko unless explicitly stated
otherwise.</p>
<p>Use mutability types and definitions (<code>var</code>) with care and
only where needed.</p>
<p>Rationale: Mutable data cannot be communicated or share across
actors. It is more error-prone and much more difficult to formally
reason about, especially when concurrency is involved.</p></li>
</ul>
<h2 id="features">Features</h2>
<h3 id="statements">Statements</h3>
<ul>
<li><p>Use <code>for</code> loops instead of <code>while</code> loops
for iterating over a numeric range or a container.</p>
<pre class="motoko"><code>for (i in Iter.range(1, 10)) { ... };
for (x in array.vals()) { ... };</code></pre>
<p>Rationale: For loops are less error-prone and easier to
read.</p></li>
<li><p>Use <code>if</code> or <code>switch</code> as expressions where
appropriate.</p>
<pre class="motoko"><code>func abs(i : Int) : Int { if (i &lt; 0) -i else i };

let delta = switch mode { case (#up) +1; case (#dn) -1 };</code></pre></li>
<li><p>Motoko requires that all expressions in a block have type
<code>()</code>, in order to prevent accidentally dropped results.</p>
<p>Use <code>ignore</code> to explicitly drop results. Do <em>not</em>
use <code>ignore</code> when it’s not needed.</p>
<pre class="motoko"><code>ignore async f();  // fire of a computation</code></pre></li>
<li><p>Motoko allows to omit the <code>return</code> at the end of a
function, because a block evaluates to its last expression.</p>
<p>Use this when a function is short and in "functional" style, that is,
the function does not contain complex control flow or side effects.</p>
<p>Use explicit <code>return</code> at the end when the function
contains other <code>return</code> statements or imperative control
flow.</p>
<pre class="motoko"><code>func add(i : Nat, j : Nat) : Nat { i + j };

func foo(a : Float, b : Float) : Float {
  let c = a*a + b*b;
  c + 2*c*c;
};

func gcd(i : Nat, j : Nat) : Nat {
  if (j == 0) i else gcd(j, i % j);
};

func gcd2(i : Nat, j : Nat) : Nat {
  var a = i;
  var b = j;
  while (b &gt; 0) {
    let c = a;
    a := b;
    b := c % b;
  };
  return a;
};</code></pre></li>
</ul>
<h3 id="objects-and-records">Objects and records</h3>
<ul>
<li><p>Use the short-hand object syntax
<code>{x1 = e1; …​ ; xN = eN}</code> when using objects as simple
<em>records</em>, i.e., data structures with no private state and no
methods.</p></li>
<li><p>Use <code>object</code> when creating singleton objects.</p></li>
<li><p>Limit the use of objects to records where possible.</p>
<p>Rationale: Only records can be sent as message parameters or results
and can be stored in stable variables. Objects with methods are also
more expensive to create and represent in memory.</p></li>
<li><p>Use full objects only as a means for encapsulating state or
behaviour.</p></li>
</ul>
<h3 id="classes">Classes</h3>
<ul>
<li><p>Use <code>class</code> to create multiple objects of the same
shape.</p></li>
<li><p>Name classes after their conceptual <em>functionality</em>, not
their <em>implementation</em>, except when having to distinguish
multiple different implementations of the same concept (for example,
<code>OrderedMap</code> vs <code>HashMap</code>).</p></li>
<li><p>Classes are both type definitions and factory functions for
objects.</p>
<p>Do not use classes unless both these roles are intended; use plain
type aliases or functions returning an object in other cases.</p></li>
<li><p>Do not overuse classes.</p>
<p>Use a module defining a plain type and functions on it where
appropriate. Use classes only as a means for encapsulating state or
behaviour.</p>
<p>Rationale: Objects with methods have disadvantages over simple record
types with separate functions (see above).</p></li>
<li><p>If values of a class are meant to be sendable (shared), the class
needs to provide a pair of <code>share</code>/<code>unshare</code>
methods that convert to/from a sharable representation, for example, as
a record.</p>
<p>:::note</p>
<p>For immutable classes it may seem more natural to make
<code>unshare</code> a kind of static function. However, even for
immutable ones it may depend on constructor arguments (such as an
ordering function), so that the a pattern like
<code>Map(compareInt).unshare(x)</code> seems appropriate.</p>
<p>:::</p></li>
<li><p>For the time being, avoid overloading classes with too many
methods, since that is currently expensive.</p>
<p>Restrict to a sufficiently small set of canonical methods and make
less essential ones that can be implemented on top of those into
functions in the enclosing module.</p></li>
<li><p>Use modules for "static" classes or methods.</p></li>
</ul>
<h3 id="modules">Modules</h3>
<ul>
<li><p>Use <code>module</code> to group definitions (including types)
and create a name spae for them.</p></li>
<li><p>Where applicable, name modules after the main type or class they
implement or provide functions for.</p></li>
<li><p>Limit each module to a single main concept/type/class or closely
entangled family of concepts/types/classes.</p></li>
</ul>
<!--
=== To be extended
-->
</body>
</html>
